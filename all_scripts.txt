 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\MasterManager.cs 
// ======================================================== 
 
﻿using UnityEngine;
/// <summary>
/// 마스터 오브젝트에 부착하는 C# 스크립트입니다.
/// 여러 매니저 스크립트를 호출합니다.
/// </summary>
public class MasterManager : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private TileLogicManager _tileLogicMng;
    [SerializeField] private PlayerLogicManager _playerLogicMng;
    [SerializeField] private BlockLogicManager _blockLogicMng;
    [SerializeField] private TileGraphicManager _tileGraphicMng;
    [SerializeField] private BlockGraphicManager _blockGraphicMng;
    [SerializeField] private EffectGraphicManager _effectGraphicMng;
    [SerializeField] private UserInterfaceManager _userInterfaceMng;
    [SerializeField] private CameraManager _cameraMng;
    [SerializeField] private SoundAdmin _soundAdmin;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 개발자 관점에서의 시스템 검증 활동 Verification
    // 유저 관점에서의 시스템 검증 활동 Validation
    private void Verification()
    {
        if (De.IsNull(_tileLogicMng)
            || De.IsNull(_playerLogicMng)
            || De.IsNull(_blockLogicMng)
            || De.IsNull(_tileGraphicMng)
            || De.IsNull(_blockGraphicMng)
            || De.IsNull(_effectGraphicMng)
            || De.IsNull(_userInterfaceMng)
            || De.IsNull(_cameraMng)
        ) {
            Tool.GameStop();
        }
    }
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메시지 함수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 스크립트 내의 변수 검증, 스크립트 내부에서만 가능한 초기화 작업
    private void Awake()
    {
        Verification();
        GameData.CreateInstance();
        // 인스펙터 값 유효성 검사
        _tileLogicMng.Verification();
        _playerLogicMng.Verification();
        _blockLogicMng.Verification();
        _tileGraphicMng.Verification();
        _blockGraphicMng.Verification();
        _effectGraphicMng.Verification();
        _userInterfaceMng.Verification();
        _cameraMng.Verification();
    }
    // 스크립트 외부 데이터를 생성하는 작업
    private void OnEnable()
    {
        // 데이터 생성
        _tileLogicMng.DataBuilder();
        _blockLogicMng.DataBuilder();
        GameData.ins.DataBuilder(_soundAdmin);
        _playerLogicMng.DataBuilder();
        _tileGraphicMng.DataBuilder();
        _blockGraphicMng.DataBuilder();
        _effectGraphicMng.DataBuilder();
        _userInterfaceMng.DataBuilder();
        _cameraMng.DataBuilder();
        // 데이터 유효성 검사
        GameData.ins.DataInspection();
    }
    // 스크립트 외부의 데이터를 사용하는 초기화 작업
    private void Start()
    {
        // 스크립트 내부 값 초기화
        _tileLogicMng.Initialize();
        _playerLogicMng.Initialize();
        _blockLogicMng.Initialize();
        _tileGraphicMng.Initialize();
        _blockGraphicMng.Initialize();
        _effectGraphicMng.Initialize();
        _userInterfaceMng.Initialize();
        _cameraMng.Initialize();
    }
    // 게임 로직
    private void Update()
    {
        _tileLogicMng.RunBeforeFrame();
        _playerLogicMng.RunBeforeFrame();
        _blockLogicMng.RunBeforeFrame();
        _tileGraphicMng.RunBeforeFrame();
        _blockGraphicMng.RunBeforeFrame();
        _effectGraphicMng.RunBeforeFrame();
        _userInterfaceMng.RunBeforeFrame();
        _cameraMng.RunBeforeFrame();
    }
    // 그래픽 로직
    private void LateUpdate()
    {
        _tileLogicMng.RunAfterFrame();
        _playerLogicMng.RunAfterFrame();
        _blockLogicMng.RunAfterFrame();
        _tileGraphicMng.RunAfterFrame();
        _blockGraphicMng.RunAfterFrame();
        _effectGraphicMng.RunAfterFrame();
        _userInterfaceMng.RunAfterFrame();
        _cameraMng.RunAfterFrame();
    }
    // 게임 종료
    private void OnDestroy()
    {
        GameData.ins = null;
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\EEffect.cs 
// ======================================================== 
 
﻿public enum EEffect : byte
{
    None = 0,
    AAA
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\EItem.cs 
// ======================================================== 
 
﻿public enum EItem
{
    None = 0,
    // Global
    Copper, // 구리
    Lead, // 납
    Sand, // 모래
    Thorium, // 토륨
    Graphite, // 흑연
    Silicon, // 실리콘
    PhaseFabric, // 위상 섬유
    SurgeAlloy, // 설금

    // Seopulo
    Scrap, // 고철
    Coal, // 석탄
    Titanium, // 티타늄
    SporePod, // 포자 꼬투리
    Metaglass, // 강화 유리
    Plastanium, // 플라스터늄
    Pyratite, // 파이라타이트
    BlastCompound, // 폭발물

    // Erekir
    Beryllium, // 베릴륨
    Tungsten, // 텅스텐
    Oxide, // 산화물
    Carbide, // 탄화물
    FissileMatter, // 핵분열 물질
    DormantCyst, // 휴면 낭종
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\GameData.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
/// <summary>
/// 마스터 매니저에서 호출하는 C# 스크립트입니다.
/// 런타임에서 사용하는 변수를 모아놓은 싱글톤 클래스입니다.
/// </summary>
public class GameData
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 & 프로퍼티 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public static GameData ins;

    // 사운드 불러오기
    private SoundAdmin _soundAdmin;
    public SoundAdmin SoundAdmin => _soundAdmin;

    // 플레이어 데이터를 저장할 클래스
    private PlayerSingle _playerSingle;
    public PlayerSingle Player
    {
        get { return _playerSingle; }
        set { _playerSingle = value; }
    }

    // 맵 격자를 기준으로 블록 데이터의 유형과 주소를 저장하는 클래스
    private BlockMap _blockMap;
    public BlockMap Blocks
    {
        get { return _blockMap; }
        set { _blockMap = value; }
    }

    // 블록 원본 데이터를 저장하는 클래스
    private PoolManagement<BlockSingle> _blockPool;
    public PoolManagement<BlockSingle> BlockPool
    {
        get { return _blockPool; }

        set { _blockPool = value; }
    }

    /// <summary>
    /// 여러 타일을 저장하는 타일 맵 구조체
    /// </summary>
    public TileMap TileMap
    {
        get { return _tileMap; }
        set {
            if (_tileMap == null) {
                _tileMap = value;
            } else {
                De.Print("블록 맵을 중복 초기화했습니다.", UnityEngine.LogType.Assert);
            }
        }
    }
    private TileMap _tileMap;

    /// <summary>
    /// 타일 ID로 SO 타일 데이터를 꺼낼 수 있는 딕셔너리
    /// </summary>
    public Dictionary<ETile, SO_Tile> TileDatabase
    {
        get { return _tileDatabase; }
        set {
            if (_tileDatabase == null) {
                _tileDatabase = value;
            } else {
                De.Print("타일 데이터베이스를 중복 초기화했습니다.", UnityEngine.LogType.Assert);
            }
        }
    }
    private Dictionary<ETile, SO_Tile> _tileDatabase;

    /// <summary>
    /// 블록 ID로 SO 블록 데이터를 꺼낼 수 있는 딕셔너리
    /// </summary>
    public Dictionary<EBlock, SO_Block> BlockDatabase
    {
        get { return _blockDatabase; }
        set {
            if (_blockDatabase == null) {
                _blockDatabase = value;
            } else {
                De.Print("블록 데이터베이스를 중복 초기화했습니다.", UnityEngine.LogType.Assert);
            }
        }
    }
    private Dictionary<EBlock, SO_Block> _blockDatabase;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public static void CreateInstance()
    {
        if (ins == null) {
            ins = new GameData();
        }
    }
    public void DataBuilder(SoundAdmin sa)
    {
        _blockPool = new PoolManagement<BlockSingle>();
        _blockMap = new BlockMap(TileMap.Width, TileMap.Height);
        _soundAdmin = sa;
    }
    public bool DataInspection()
    {
        if (De.IsNull(ins)
            || De.IsNull(_blockMap)
            || De.IsNull(_blockDatabase)
            || De.IsNull(_blockPool)
            || De.IsNull(_tileMap)
            || De.IsNull(_tileDatabase)
        ) {
            return false;
        }
        return true;
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Block_Data\BlockMap.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

/// <summary>
/// 2D 격자 맵의 블록 상태를 관리하는 핵심 클래스입니다.
/// </summary>
public class BlockMap
{
    #region ─────────────────────────▶ 내부 변수 ◀─────────────────────────
    private BlockRef[] _blocks;
    private readonly int _width;
    private readonly int _height;
    // 재사용 버퍼 (최대 블록 크기 = 6*6)
    private readonly int[] _cellBuffer = new int[36];

    private GameData _game;
    private TileMap _tile;
    private Dictionary<EBlock, SO_Block> _so;
    private PoolManagement<BlockSingle> _pool;
    #endregion

    #region ─────────────────────────▶ 접근자 ◀─────────────────────────
    /// <summary>
    /// 맵의 가로 길이(셀 개수)입니다.
    /// </summary>
    public int Width => _width;

    /// <summary>
    /// 맵의 세로 길이(셀 개수)입니다.
    /// </summary>
    public int Height => _height;

    /// <summary>
    /// 맵의 가로 길이 * 세로 길이입니다.
    /// </summary>
    public int Length => _blocks.Length;

    /// <summary>
    /// 특정 좌표에 있는 블록의 참조를 읽습니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public BlockRef GetBlock(int index) => _blocks[index];

    /// <summary>
    /// 특정 좌표에 있는 블록의 참조를 읽습니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int GetAdress(int index) => _blocks[index].adress;

    /// <summary>
    /// 특정 좌표에 있는 블록의 실제 데이터를 읽습니다.
    /// 셀이 비어있을 경우 호출하면 안됩니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ref readonly BlockSingle ReadSingle(int index)
    {
        return ref _pool.Read(_blocks[index].adress);
    }

    /// <summary>
    /// 특정 좌표에 있는 블록의 실제 데이터를 수정 가능하게 반환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ref BlockSingle GetSingleRef(int index)
    {
        return ref _pool.GetRef(_blocks[index].adress);
    }

    /// <summary>
    /// 특정 좌표를 블록이 차지하고 있지 않은지 검사합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsVoid(int index) => _blocks[index].IsVoid();

    /// <summary>
    /// 특정 좌표를 블록이 차지하고 있는지 검사합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsExist(int index) => !_blocks[index].IsVoid();

    /// <summary>
    /// 특정 좌표가 맵 내부에 있는지 검사합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool InMap(int index) => (0 <= index) && (index < Length);
    #endregion

    #region ─────────────────────────▶ 외부 공개 메서드 ◀─────────────────────────
    public BlockMap(int width, int height)
    {
        _width = width;
        _height = height;
        _blocks = new BlockRef[width * height];
        // 모든 셀을 빈 상태로 초기화
        for (int i = 0; i < _blocks.Length; ++i)
            _blocks[i].adress = -1;
        // 캐싱
        _game = GameData.ins;
        _tile = _game.TileMap;
        _so = _game.BlockDatabase;
        _pool = _game.BlockPool;
    }

    /// <summary>
    /// 특정 좌표에 블록을 설치할 수 있는지 검사합니다.
    /// </summary>
    public bool CanPlace(int index, EBlock id, ERotation rotation = ERotation.Up)
    {
        De.IsFalse(_so.ContainsKey(id), LogType.Assert);
        SO_Block so = _so[id];
        Vector2Int size = new Vector2Int((int)so.Size.x, (int)so.Size.y);
        // 점유할 모든 셀 순회
        int count = GetOccupiedCells(index, size, rotation, _cellBuffer);
        for (int i = 0; i < count; ++i) {
            int cellIndex = _cellBuffer[i];
            // 맵 범위, 블록 없음, 지상 타일
            if (!InMap(cellIndex))
                return false;
            if (!IsVoid(cellIndex))
                return false;
            if (!_tile.IsGround(cellIndex))
                return false;
        }
        return true;
    }

    /// <summary>
    /// 특정 좌표에 블록 설치를 시도합니다.
    /// </summary>
    public bool TryPlace(int index, EBlock id, ERotation rotation = ERotation.Up)
    {
        if (!CanPlace(index, id, rotation)) {
            De.Print($"블록 생성 실패 : {UGrid.IndexToGridV(index, _width)}, {id}, {rotation}");
            return false;
        }
        Place(index, id, rotation);
        De.Print($"블록 생성 성공 : {UGrid.IndexToGridV(index, _width)}, {id}, {rotation}");
        return true;
    }

    /// <summary>
    /// 특정 좌표를 차지하고 있는 블록을 삭제합니다.
    /// 해당 블록이 점유하는 모든 셀이 함께 해제됩니다.
    /// </summary>
    public void TryRemove(int index)
    {
        if (_blocks[index].IsVoid())
            return;
        int adress = _blocks[index].adress;
        TryRemoveByAdress(adress);
    }

    /// <summary>
    /// 풀 주소로 블록을 삭제합니다.
    /// </summary>
    public void TryRemoveByAdress(int adress)
    {
        if (!_pool.IsExist(adress))
            return;
        ref readonly BlockSingle data = ref _pool.Read(adress);
        // 점유 셀 해제
        int count = GetOccupiedCells(data.index, data.size, data.rotation, _cellBuffer);
        for (int i = 0; i < count; ++i)
            _blocks[_cellBuffer[i]].Init();
        // 데이터 삭제
        _pool.Destroy(adress);
    }

    /// <summary>
    /// 블록이 점유하는 모든 셀 인덱스를 buffer에 채우고 개수를 반환합니다.
    /// </summary>
    public int GetOccupiedCells(int index, Vector2Int size, ERotation rotation, int[] buffer)
    {
        (int gridX, int gridY) = UGrid.IndexToGrid(index, _width);
        int sizeX = size.x;
        int sizeY = size.y;
        int dirX, dirY; // 확장 방향 (+1 또는 -1)
        int spanX, spanY; // 실제 확장할 가로, 세로 크기

        switch (rotation) {
            // 왼쪽 아래가 중심 = (+x, +y) 확장
            case ERotation.Up:
                dirX = 1;
                dirY = 1;
                spanX = sizeX;
                spanY = sizeY;
                break;
            // 왼쪽 위가 중심 = (+x, -y) 확장
            case ERotation.Right:
                dirX = 1;
                dirY = -1;
                spanX = sizeY;
                spanY = sizeX;
                break;
            // 오른쪽 위가 중심 = (-x, -y) 확장
            case ERotation.Down:
                dirX = -1;
                dirY = -1;
                spanX = sizeX;
                spanY = sizeY;
                break;
            // 오른쪽 아래가 중심 = (-x, +y) 확장
            case ERotation.Left:
                dirX = -1;
                dirY = 1;
                spanX = sizeY;
                spanY = sizeX;
                break;
            // 예외 발생
            default:
                dirX = 1;
                dirY = 1;
                spanX = sizeX;
                spanY = sizeY;
                De.Print("GetOccupiedCells에서 존재하지 않는 회전 열거형을 받았습니다.");
                break;
        }
        // 회전을 고려하여 점유한 셀 순환
        int count = 0;
        for (int y = 0; y < spanY; ++y) {
            for (int x = 0; x < spanX; ++x) {
                int gx = gridX + x * dirX;
                int gy = gridY + y * dirY;
                // 맵 범위 검사
                if (gx < 0 || _width <= gx || gy < 0 || _height <= gy)
                    continue;
                buffer[count++] = UGrid.GridToIndex(gx, gy, _width);
            }
        }
        return count;
    }

    /// <summary>
    /// 블록의 월드 좌표를 반환합니다. (실수)
    /// 어떤 회전이든 블록 스프라이트의 시각적 중심은 점유 영역의 정중앙입니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Vector2 GetRenderPos(int index, Vector2Int size, ERotation rotation)
    {
        (int cellX, int cellY) = UGrid.IndexToGrid(index, _width);
        int sizeX = size.x;
        int sizeY = size.y;

        float renderX, renderY;
        switch (rotation) {
            // 왼쪽 아래가 중심 = (+x, +y) 확장
            case ERotation.Up:
                renderX = cellX + sizeX * 0.5f;
                renderY = cellY + sizeY * 0.5f;
                break;
            // 왼쪽 위가 중심 = (+x, -y) 확장
            case ERotation.Right:
                renderX = cellX + sizeY * 0.5f;
                renderY = cellY - sizeX * 0.5f;
                break;
            // 오른쪽 위가 중심 = (-x, -y) 확장
            case ERotation.Down:
                renderX = cellX - sizeX * 0.5f;
                renderY = cellY - sizeY * 0.5f;
                break;
            // 오른쪽 아래가 중심 = (-x, +y) 확장
            case ERotation.Left:
                renderX = cellX - sizeY * 0.5f;
                renderY = cellY + sizeX * 0.5f;
                break;
            // 예외 발생
            default:
                renderX = cellX + sizeX * 0.5f;
                renderY = cellY + sizeY * 0.5f;
                De.Print("GetRenderPos에서 존재하지 않는 회전 열거형을 받았습니다.");
                break;
        }
        return new Vector2(renderX, renderY);
    }
    #endregion

    #region ─────────────────────────▶ 내부 메서드 ◀─────────────────────────
    /// <summary>
    /// 특정 좌표에 블록을 설치합니다.
    /// </summary>
    private void Place(int index, EBlock id, ERotation rotation = ERotation.Up)
    {
        De.IsFalse(_so.ContainsKey(id), LogType.Assert);
        SO_Block so = _so[id];
        Vector2Int size = new Vector2Int((int)so.Size.x, (int)so.Size.y);
        // 실제 블록 데이터 생성
        BlockSingle data = new BlockSingle(id, rotation, index, size);
        int adress = _pool.Create(data);
        if (De.IsFalse(0 <= adress, LogType.Warning))
            return;
        // 점유할 모든 셀에 같은 주소를 기록
        int count = GetOccupiedCells(index, size, rotation, _cellBuffer);
        for (int i = 0; i < count; ++i)
            _blocks[_cellBuffer[i]].adress = adress;
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Block_Data\BlockRef.cs 
// ======================================================== 
 
﻿/// <summary>
/// 격자 맵에 저장할 블록 데이터입니다.
/// </summary>
public struct BlockRef
{
    public int adress;

    public BlockRef(int adress)
    {
        this.adress = adress;
    }

    public bool IsVoid() => adress == -1;
    public void Init() => adress = -1;
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Block_Data\BlockSingle.cs 
// ======================================================== 
 
﻿using UnityEngine;

public struct BlockSingle
{
    public EBlock id;
    public ERotation rotation;
    public int index; // 블록의 중심(축)이 되는 셀의 1차원 좌표
    public Vector2Int size;

    // 부품 회전 값
    public float partAngle_1; // Body 각도 (지수 보간으로 플레이어 바라보기)
    public float partAngle_2; // Turret 각도 (일정 속도로 플레이어 바라보기)
    public float partAngle_3; // Rotation 자전 각도

    // 이펙트 타이머 (0 ~ fullCycle 사이 누적)
    public float effectTimer;

    public BlockSingle(EBlock id, ERotation rotation, int index, Vector2Int size)
    {
        this.id = id;
        this.rotation = rotation;
        this.index = index;
        this.size = size;
        this.partAngle_1 = 0f;
        this.partAngle_2 = 0f;
        this.partAngle_3 = 0f;
        this.effectTimer = 0f;
    }

    public bool IsVoid() => id == EBlock.None;

    public void Init()
    {
        id = EBlock.None;
        rotation = ERotation.None;
        index = -1;
        size = Vector2Int.zero;
        partAngle_1 = 0f;
        partAngle_2 = 0f;
        partAngle_3 = 0f;
        effectTimer = 0f;
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Block_Data\EBlock.cs 
// ======================================================== 
 
﻿public enum EBlock : byte
{
    None = 0,
    // Seopluo Core
    CoreShard,
    CoreFoundation,
    CoreNucleus,

    // Seopulo Drill
    MechanicalDrill, // 기계식 드릴
    PneumaticDrill, // 공압 드릴
    LaserDrill, // 레이저 드릴
    AirblastDrill, // 압축 공기분사 드릴
    Cultivator, // 온실
    WaterExtractor, // 물 추출기
    OilExtractor, // 석유 추출기

    // Seopulo Pipe
    Conduit, // 파이프
    PulseConduit, // 펄스 파이프
    PlatedConduit, // 도금된 파이프
    LiquidRouter, // 액체 분배기
    LiquidContainer, // 액체 컨테이너
    LiquidTank, // 액체 탱크
    LiquidJunction, // 액체 교차기
    BridgeConduit, // 다리 파이프
    PhaseConduit, // 위상 파이프

    // Seopulo Turret
    Duo, // 듀오
    Scatter, // 스캐터
    Scorch, // 스코치
    Hail, // 헤일
    Wave, // 파도
    Lancer, // 랜서
    Arc, // 아크
    Parallax, // 패럴랙스
    Swarmer, // 스웜
    Salvo, // 살보
    Segment, // 세그먼트
    Tsunami, // 쓰나미
    Fuse, // 퓨즈
    Ripple, // 립플
    Cyclone, // 사이클론
    Foreshadow, // 포어쉐도우
    Spectre, // 스펙터
    Meltdown, // 멜트다운

    // Seopulo Factory
    GraphitePress, // 흑연 압축기
    MultiPress, // 다중 압축기
    SiliconSmelter, // 실리콘 제련소
    SiliconCrucible, // 실리콘 도가니
    Kiln, // 가마
    PlastaniumCompressor, // 플라스터늄 압축기
    PhaseWeaver, // 메타 합성기
    AlloySmelter, // 설금 제련소
    CryofluidMixer, // 냉각수 혼합기
    PyratiteMixer, // 파이라타이트 혼합기
    BlastMixer, // 폭발물 혼합기
    Melter, // 융해기
    Separator, // 광재 분리기
    Disassembler, // 광재 분해기
    SporePress, // 포자 압축기
    Pulverizer, // 분쇄기 
    CoalCentrifuge, // 석탄 정제기
    Incinerator, // 소각로

    // Seopulo Wall
    CopperWall, // 구리 벽
    LargeCopperWall, // 대형 구리 벽
    TitaniumWall, // 티타늄 벽
    LargeTitaniumWall, // 대형 티타늄 벽
    PlastaniumWall, // 플라스터늄 벽
    LargePlastaniumWall, // 대형 플라스터늄 벽
    ThoriumWall, // 토륨 벽
    LargeThoriumWall, // 대형 토륨 벽
    PhaseWall, // 위상 벽
    LargePhaseWall, // 대형 위상 벽
    SurgeWall, // 설금 벽
    LargeSurgeWall, // 대형 설금 벽
    Door, // 문
    LargeDoor, // 대형 문
    ScrapWall, // 조각 벽
    LargeScrapWall, // 대형 조각 벽
    HugeScrapWall, // 거대한 조각 벽
    GiganticScrapWall, // 엄청나게 큰 조각 벽
    Thruster, // 쓰러스터
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Block_Data\ERotation.cs 
// ======================================================== 
 
﻿/// <summary>
/// 블록의 회전을 직관적으로 다루는 열거형입니다.
/// </summary>
public enum ERotation : byte
{
    None = 0,
    Up,
    Right,
    Down,
    Left
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Graphic_Data\BatchLists.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;
/// <summary>
/// 그래픽을 그리기 위한 데이터를 저장하는 구조체입니다.
/// </summary>
public struct BatchLists
{
    private readonly Material _material;
    public List<List<Matrix4x4>> matrices;

    public Material Mat => _material;

    public BatchLists(Material material, int capacity = 2)
    {
        this._material = material;
        this.matrices = new List<List<Matrix4x4>>();
        matrices.Add(new List<Matrix4x4>(2));
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Graphic_Data\BlockSpriteKey.cs 
// ======================================================== 
 
﻿using System;

/// <summary>
/// 블록 ID와 스프라이트 인덱스를 조합하여 배치 렌더링의 키로 사용하는 구조체입니다.
/// 같은 블록이라도 레이어(Body, Turret 등)별로 다른 Material을 사용해야 하므로 분리합니다.
/// </summary>
public struct BlockSpriteKey : IEquatable<BlockSpriteKey>
{
    public readonly EBlock id;
    public readonly int spriteIndex;

    public BlockSpriteKey(EBlock id, int spriteIndex)
    {
        this.id = id;
        this.spriteIndex = spriteIndex;
    }

    public bool Equals(BlockSpriteKey other)
    {
        return id == other.id && spriteIndex == other.spriteIndex;
    }

    public override bool Equals(object obj)
    {
        return obj is BlockSpriteKey other && Equals(other);
    }

    public override int GetHashCode()
    {
        return (((int)id << 5) - 1) ^ spriteIndex;
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Graphic_Data\ESpriteType.cs 
// ======================================================== 
 
﻿/// <summary>
/// 스프라이트의 회전 및 동작 방식을 결정하는 열거형입니다.
/// </summary>
public enum ESpriteType
{
    None = 0,
    Body,       // 플레이어를 바라봄
    Turret,     // 플레이어를 바라봄
    Static,     // 회전 없음 (설치 방향 고정)
    Rotation,   // 일정 속도로 자전
    Effect,     // 특정 상황에서 투명도 변화 (추후 구현)
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Graphic_Data\SpriteInfo.cs 
// ======================================================== 
 
﻿using UnityEngine;
/// <summary>
/// 스프라이트를 그리기 위한 정보를 담는 구조체입니다.
/// </summary>
[System.Serializable]
public struct SpriteInfo
{
    [Header("스프라이트 정보")]
    public Sprite sprite;
    public ESpriteType type;
    [Tooltip("Z값은 0 ~ 0.0009 이내로 입력할 것")]
    public Vector3 offset;
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Player_Data\BuildOrder.cs 
// ======================================================== 
 
﻿/// <summary>
/// 건설 예정 데이터를 담는 구조체입니다.
/// </summary>
public struct BuildOrder
{
    public int index;
    public EOrderType type;
    public EBlock id;
    public ERotation rotation;

    public BuildOrder(int index, EOrderType type, EBlock id, ERotation rotation)
    {
        this.index = index;
        this.type = type;
        this.id = id;
        this.rotation = rotation;
    }

    public bool IsVoid() => type == EOrderType.None;
}

public enum EOrderType : byte { None, Build, Destroy }
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Player_Data\EBuildState.cs 
// ======================================================== 
 
﻿/// <summary>
/// 코어 유닛의 건설 상태를 표현하는 열거형입니다.
/// </summary>
public enum EBuildState : byte
{
    None = 0,
    Build,
    Demolish
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Player_Data\PlayerSingle.cs 
// ======================================================== 
 
﻿using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// 플레이어 데이터를 저장하는 클래스입니다.
/// </summary>
public class PlayerSingle
{
    #region ─────────────────────────▶ 변수 ◀─────────────────────────
    public Vector2 pos;
    public float angle;

    // 건설
    public float buildRemain;
    public readonly float buildRange;
    public readonly float buildInterval;
    public readonly float buildSpeedMultiplier;
    public EBuildState buildState;

    // 커서
    public Vector2 CursorInGrid { get; private set; }
    public bool CursorMoved { get; private set; }

    // 선택 블록 (마우스를 따라다니는 미리보기)
    public readonly List<SelectedBlock> selecteds;
    // 디자인 블록 (맵에 설치된 건설 예정 블록)
    public Dictionary<int, BuildOrder> designs;

    // 철거 영역 시각화
    public bool demolishActive;
    public int demolishMinX;
    public int demolishMinY;
    public int demolishMaxX;
    public int demolishMaxY;

    // 건설/철거 중 바라보기 (PlayerMover에서 이동 방향 회전 스킵용)
    public bool lookAtBuild;

    // 복사 영역 시각화
    public bool copyActive;
    public int copyMinX;
    public int copyMinY;
    public int copyMaxX;
    public int copyMaxY;
    #endregion

    #region ─────────────────────────▶ 생성자 ◀─────────────────────────
    public PlayerSingle(int width, int height, float buildRange, float buildInterval, float buildSpeedMultiplier, int capacity = 256)
    {
        this.pos = new Vector2(width / 2, height / 2);
        this.angle = 0f;
        this.buildRemain = 0f;
        this.buildRange = buildRange;
        this.buildInterval = buildInterval;
        this.buildSpeedMultiplier = buildSpeedMultiplier;
        this.buildState = EBuildState.None;
        this.CursorInGrid = Vector2.zero;
        this.CursorMoved = false;
        this.selecteds = new List<SelectedBlock>(capacity);
        this.designs = new Dictionary<int, BuildOrder>(capacity);
        this.demolishActive = false;
    }
    #endregion

    #region ─────────────────────────▶ 메서드 ◀─────────────────────────
    public bool UpdateCursor(Camera camera)
    {
        Vector2 mousePos = Tool.GetMousePos(camera);
        Vector2 newGrid = UGrid.WorldToGrid(mousePos);
        if (CursorInGrid != newGrid) {
            CursorInGrid = newGrid;
            CursorMoved = true;
            return true;
        }
        CursorMoved = false;
        return false;
    }

    public void ClearBuild()
    {
        buildState = EBuildState.None;
        designs.Clear();
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Player_Data\SelectedBlock.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 선택한 블록의 정보를 담는 구조체입니다.
/// 마우스를 따라다니는 미리보기 블록 하나에 대응합니다.
/// </summary>
public struct SelectedBlock
{
    /// <summary> 그룹 중심(커서) 기준 상대 그리드 좌표 </summary>
    public float offsetX;
    public float offsetY;
    /// <summary> 블록 종류 </summary>
    public EBlock id;
    /// <summary> 설치 방향 </summary>
    public ERotation rotation;

    public SelectedBlock(float offsetX, float offsetY, EBlock id, ERotation rotation)
    {
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.id = id;
        this.rotation = rotation;
    }

    public bool IsVoid() => id == EBlock.None;
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Scriptable_Object\SO_Block.cs 
// ======================================================== 
 
﻿using UnityEngine;

[CreateAssetMenu(fileName = "Block", menuName = "ScriptableObjects/Block/Universal", order = 1)]
public class SO_Block : SO_Matter
{
    [Header("ID")]
    [SerializeField] protected EBlock _id;
    public EBlock ID => _id;
    [SerializeField] protected Vector2Int _size = new Vector2Int(1, 1);
    public Vector2Int Size => _size;

    [Header("블록 특성")]
    [SerializeField] protected bool _rotatable = true;
    public bool Rotatable => _rotatable;
    [SerializeField] protected bool _connection = false;
    public bool Connection => _connection;

    [Header("부품 회전")]
    [Tooltip("Body 회전 보간 계수 (지수 보간). 값이 클수록 빠르게 추적합니다.")]
    [SerializeField] protected float _bodyRotateSpeed = 5f;
    public float BodyRotateSpeed => _bodyRotateSpeed;

    [Tooltip("Turret 최대 회전 속도 (도/초). 일정 속도로 목표까지 회전합니다.")]
    [SerializeField] protected float _turretRotateSpeed = 180f;
    public float TurretRotateSpeed => _turretRotateSpeed;

    [Tooltip("Rotation 자전 속도 (도/초)")]
    [SerializeField] protected float _rotationSpeed = 90f;
    public float RotationSpeed => _rotationSpeed;

    [Header("이펙트")]
    [Tooltip("Effect 스프라이트의 반주기 (초). 이 시간 동안 투명→불투명, 다시 이 시간 동안 불투명→투명")]
    [SerializeField] protected float _effectCycleTime = 1f;
    public float EffectCycleTime => _effectCycleTime;

    protected override void OnValidate()
    {
        base.OnValidate();
        if (_size.x <= 0) _size.x = 1;
        if (_size.y <= 0) _size.y = 1;
        if (_bodyRotateSpeed < 0.1f) _bodyRotateSpeed = 0.1f;
        if (_turretRotateSpeed < 0.1f) _turretRotateSpeed = 0.1f;
        if (_effectCycleTime < 0.01f) _effectCycleTime = 0.01f;
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Scriptable_Object\SO_Effect.cs 
// ======================================================== 
 
﻿using UnityEngine;

[CreateAssetMenu(fileName = "Effect", menuName = "ScriptableObjects/Effect/Universal", order = 1)]
public class SO_Effect : SO_Matter
{
    [Header("ID")]
    [SerializeField] protected EEffect _id;
    public EEffect ID => _id;
    [SerializeField] protected Vector2 _size = new Vector2(1f, 1f);
    public Vector2 Size => _size;
    
    [Header("애니메이션")]
    [SerializeField] float _frameTime;
    public float FrameTime => _frameTime;
    public float Duration => _frameTime * _sprite.Length;

    // 개발자가 이상한 값을 입력했는지 검사하고 조정합니다.
    protected override void OnValidate()
    {
        base.OnValidate();
        if (_size.x <= 0) _size.x = 0.1f;
        if (_size.y <= 0) _size.y = 0.1f;
        if (_frameTime < 0f) _frameTime = 0.1f;
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Scriptable_Object\SO_Matter.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 모든 데이터를 담는 스크립터블 오브젝트입니다.
/// </summary>
public abstract class SO_Matter : ScriptableObject
{
    [Header("기본 정보")]
    [SerializeField] protected SpriteInfo[] _sprite;
    [SerializeField] protected string _label;
    public string Label => _label;
    

    /// <summary>
    /// 스프라이트 구조체 정보를 반환합니다.
    /// </summary>
    /// <param name="index"></param>
    /// <returns></returns>
    public ref readonly SpriteInfo GetSpriteInfo(int index)
    {
         return ref _sprite[index];
    }

    /// <summary>
    /// 스프라이트 구조체 정보를 반환합니다.
    /// </summary>
    /// <param name="index"></param>
    /// <returns></returns>
    public ref readonly SpriteInfo[] GetSpriteInfoAll()
    {
         return ref _sprite;
    }

    /// <summary>
    /// 스프라이트 정보를 반환합니다.
    /// </summary>
    /// <param name="index"></param>
    /// <returns></returns>
    public Sprite GetSprite(int index)
    {
        return _sprite[index].sprite;
    }

    /// <summary>
    /// 텍스처 정보를 반환합니다.
    /// </summary>
    /// <param name="index"></param>
    /// <returns></returns>
    public Texture2D GetTexture(int index)
    {
        return _sprite[index].sprite.texture;
    }

    public int SpriteCount => _sprite.Length;

    // 개발자가 값을 제대로 입력했는지 검사하고 조정합니다.
    protected virtual void OnValidate()
    {
        // 스프라이트 구조체 검증
        UArray.IsInitedArray(_sprite);
        int length = _sprite.Length;
        for (int i = 0; i < length; ++i) {
            var sp = _sprite[i];
            De.IsNull(sp.sprite);
            De.IsTrue(sp.type == ESpriteType.None);

            sp.offset.x = Mathf.Clamp(sp.offset.x, -10f, 10f);
            sp.offset.y = Mathf.Clamp(sp.offset.y, -10f, 10f);
            sp.offset.z = Mathf.Clamp(sp.offset.z, -0.0009f, 0f);
            _sprite[i] = sp;
        }
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Scriptable_Object\SO_Tile.cs 
// ======================================================== 
 
﻿using UnityEngine;

[CreateAssetMenu(fileName = "Tile", menuName = "ScriptableObjects/Tile/Universal", order = 1)]
public class SO_Tile : SO_Matter
{
    [Header("ID")]
    [SerializeField] protected ETile _id;
    public ETile ID => _id;
    [SerializeField] protected ETileType _type;
    public ETileType Type => _type;
    [SerializeField] protected Vector2Int _size = new Vector2Int(1, 1);
    public Vector2Int Size => _size;

    // 개발자가 이상한 값을 입력했는지 검사하고 조정합니다.
    protected override void OnValidate()
    {
        base.OnValidate();
        if (_size.x <= 0) _size.x = 1;
        if (_size.y <= 0) _size.y = 1;
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\System_Data\PoolManagement.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using System;
/// <summary>
/// 게임 데이터에서 호출하는 C# 스크립트입니다.
/// 런타임에서 사용하는 각종 데이터를 저장하거나 꺼낼 수 있는 클래스입니다. 
/// 배열을 필요한 만큼만 확장하여 데이터를 저장합니다.
/// </summary>
public class PoolManagement<T> where T : struct
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    protected T[] _dataList;
    protected bool[] _isActive;
    protected Stack<int> _freeIndex;
    protected int _count;
    protected int _nextIndex;

    public PoolManagement(int capacity = byte.MaxValue)
    {
        Initialize(capacity);
    }

    /// <summary>
    /// 현재 사용중인 데이터 개수
    /// </summary>
    public int Count => _count;

    /// <summary>
    /// 현재까지 데이터가 가장 많이 생성되었을 때의 개수
    /// </summary>
    public int Capacity => _nextIndex;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 새로운 데이터 등록
    /// 생성 실패했을 경우 -1을 반환
    public int Create(T data)
    {
        // 유닛 수 최대치 도달
        if (De.IsTrue(short.MaxValue < _nextIndex)) {
            return -1;
        }
        int newIndex;
        // 재사용할 인덱스가 있음
        if (0 < _freeIndex.Count) {
            newIndex = _freeIndex.Pop();
        }
        // 새로운 인덱스
        else {
            // 공간 부족
            if (_dataList.Length <= _nextIndex) {
                
                if (!UArray.TryResizeArray(ref _dataList, 1.5d)) { // 배열 확장 시도
                    return -1;
                }
                UArray.TryResizeArray(ref _isActive, 1.5d);
            }
            // 배열 확장 성공
            newIndex = _nextIndex++;
        }
        // 데이터 저장
        _count++;
        _dataList[newIndex] = data;
        _isActive[newIndex] = true;
        return newIndex;
    }

    /// <summary>
    /// 해당 인덱스를 풀에 반납 (데이터 삭제 처리)
    /// </summary>
    public void Destroy(int index)
    {
        _count--;
        _freeIndex.Push(index);
        _isActive[index] = false;
    }

    /// <summary>
    /// 해당 인덱스에 데이터가 존재할 경우
    /// </summary>
    public bool IsExist(int index)
    {
        return _isActive[index];
    }

    /// <summary>
    /// 수정할 수 없는 데이터를 반환
    /// </summary>
    public ref readonly T Read(int index) => ref _dataList[index];

    /// <summary>
    /// 수정 가능한 데이터를 반환
    /// </summary>
    public ref T GetRef(int index) => ref _dataList[index];

    /// <summary>
    /// 모든 인덱스를 풀에 반납
    /// </summary>
    public void Clear()
    {
        _count = 0;
        for (int i = 0; i < _nextIndex; ++i) {
            if (IsExist(i)) {
                Destroy(i);
            }
        }
    }

    /// <summary>
    /// 메모리를 새로 할당하여 클래스를 완전히 초기화
    /// </summary>
    public void Initialize(int capacity = byte.MaxValue)
    {
        _dataList = new T[capacity];
        _isActive = new bool[capacity];
        Array.Fill<bool>(_isActive, false);
        _freeIndex = new Stack<int>(capacity);
        _count = 0;
        _nextIndex = 0;
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Tile_Data\ETile.cs 
// ======================================================== 
 
﻿public enum ETile
{
    None = 0,
    // Ground
    FerricFloor_1,
    FerricFloor_2,
    FerricFloor_3,
    FerricFloor_4,
    // Wall
    FerricWall_1,
    FerricWall_2,
    BigFerricWall
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Tile_Data\ETileType.cs 
// ======================================================== 
 
public enum ETileType
{
    Air,
    Ground,
    Wall,
    Liquid
} 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Tile_Data\TileMap.cs 
// ======================================================== 
 
﻿using System.Runtime.CompilerServices;

/// <summary>
/// 2D 격자 맵의 타일 상태를 관리하는 클래스입니다.
/// </summary>
public class TileMap
{
    #region ─────────────────────────▶ 내부 변수 ◀─────────────────────────
    private readonly TileSingle[] _tiles;
    private readonly int _width;
    private readonly int _height;
    private readonly int _outlineWall;
    #endregion

    #region ─────────────────────────▶ 접근자 ◀─────────────────────────
    /// <summary>
    /// 맵의 가로 길이(셀 개수)입니다.
    /// </summary>
    public int Width => _width;

    /// <summary>
    /// 맵의 세로 길이(셀 개수)입니다.
    /// </summary>
    public int Height => _height;

    /// <summary>
    /// 맵의 가로 길이 * 세로 길이입니다.
    /// </summary>
    public int Length => _tiles.Length;

    /// <summary>
    /// 맵 테두리 벽의 두께(셀 개수)입니다.
    /// </summary>
    public int OutlineWall => _outlineWall;

    /// <summary>
    /// 특정 좌표에 있는 타일 데이터를 읽습니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ref readonly TileSingle Read(int index) => ref _tiles[index];

    /// <summary>
    /// 특정 좌표가 지상 타일인지 검사합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsGround(int index) => _tiles[index].type == ETileType.Ground;

    /// <summary>
    /// 특정 좌표가 벽 타일인지 검사합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsWall(int index) => _tiles[index].type == ETileType.Wall;

    /// <summary>
    /// 특정 좌표가 빈 타일인지 검사합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsVoid(int index) => _tiles[index].id == ETile.None;

    /// <summary>
    /// 특정 좌표에 광석이 있는지 검사합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool HasOre(int index) => _tiles[index].ore != EItem.None;

    /// <summary>
    /// 특정 좌표가 맵 내부에 있는지 검사합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool InMap(int index) => (0 <= index) && (index < Length);

    /// <summary>
    /// 타일맵이 유효하지 않은 상태인지 검사합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsInvalid() => (_width <= 0) || (_height <= 0) || (_outlineWall < 0);
    #endregion

    #region ─────────────────────────▶ 외부 공개 메서드 ◀─────────────────────────
    public TileMap(int width, int height, int outlineWall)
    {
        _width = width;
        _height = height;
        _outlineWall = outlineWall;
        // 배열 초기화
        _tiles = new TileSingle[width * height];
        for (int i = 0; i < _tiles.Length; ++i)
            _tiles[i] = new TileSingle(ETile.None, ETileType.Air, EItem.None);
    }

    /// <summary>
    /// 특정 좌표의 타일을 설정합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetTile(int index, TileSingle tile)
    {
        _tiles[index] = tile;
    }

    /// <summary>
    /// 특정 좌표의 타일을 설정합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetTile(int index, ETile id, ETileType type, EItem ore = EItem.None)
    {
        _tiles[index] = new TileSingle(id, type, ore);
    }

    /// <summary>
    /// 특정 좌표의 타일 요소를 설정합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetID(int index, ETile id)
    {
        _tiles[index].id = id;
    }

    /// <summary>
    /// 특정 좌표의 타일 요소를 설정합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetType(int index, ETileType type)
    {
        _tiles[index].type = type;
    }

    /// <summary>
    /// 특정 좌표의 타일 요소를 설정합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetOre(int index, EItem ore)
    {
        _tiles[index].ore = ore;
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Data\Tile_Data\TileSingle.cs 
// ======================================================== 
 
﻿/// <summary>
/// 타일 하나의 정보를 담는 구조체입니다.
/// </summary>
public struct TileSingle
{
    public ETile id;
    public ETileType type;
    public EItem ore;

    public TileSingle(ETile id, ETileType type, EItem ore)
    {
        this.id = id;
        this.type = type;
        this.ore = ore;
    }

    public bool IsVoid() => id == ETile.None;
    public bool IsGround() => type == ETileType.Ground;
    public bool IsWall() => type == ETileType.Wall;
    public bool HasOre() => ore != EItem.None;

    public void Init()
    {
        id = ETile.None;
        type = ETileType.Air;
        ore = EItem.None;
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Editor\SearchableEnumAttribute.cs 
// ======================================================== 
 
﻿using UnityEngine;

public class SearchableEnumAttribute : PropertyAttribute { }
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Editor\SearchableEnumDrawer.cs 
// ======================================================== 
 
﻿using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using UnityEditor.IMGUI.Controls;

[CustomPropertyDrawer(typeof(SearchableEnumAttribute))]
public class SearchableEnumDrawer : PropertyDrawer
{
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        if (property.propertyType != SerializedPropertyType.Enum) {
            EditorGUI.PropertyField(position, property, label);
            return;
        }

        // 라벨 그리기
        position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);

        // 현재 선택된 Enum 이름 가져오기
        string currentName = property.enumNames[property.enumValueIndex];

        // 버튼 그리기 (클릭 시 팝업 오픈)
        if (GUI.Button(position, currentName, EditorStyles.popup)) {
            var dropdown = new EnumDropdown(property);
            dropdown.Show(position);
        }
    }

    // Unity의 고급 드롭다운 API 사용
    private class EnumDropdown : AdvancedDropdown
    {
        private SerializedProperty _property;
        private string[] _enumNames;

        public EnumDropdown(SerializedProperty property) : base(new AdvancedDropdownState())
        {
            _property = property;
            _enumNames = property.enumNames;
        }

        protected override AdvancedDropdownItem BuildRoot()
        {
            var root = new AdvancedDropdownItem("Select Enum");

            for (int i = 0; i < _enumNames.Length; i++) {
                // Enum 이름에 슬래시(/)가 있다면 하위 메뉴로 자동 분류 (선택 사항)
                // 예: "Enemy/Normal", "Enemy/Boss"
                var item = new AdvancedDropdownItem(_enumNames[i])
                {
                    id = i // 인덱스를 ID로 저장
                };
                root.AddChild(item);
            }

            return root;
        }

        protected override void ItemSelected(AdvancedDropdownItem item)
        {
            _property.serializedObject.Update();
            _property.enumValueIndex = item.id; // 저장해둔 인덱스로 값 변경
            _property.serializedObject.ApplyModifiedProperties();
        }
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\Block_Graphic\BlockBatchBuilder.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 블록 그래픽 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 매 프레임 PoolManagement&lt;BlockSingle&gt;의 활성 블록만 순회하여
/// 렌더링 배치 데이터를 구성합니다.
///
/// Body/Turret/Rotation/Static → BatchLists 배치 렌더링
/// Effect → 인스턴스별 투명도가 필요하므로 Graphics.DrawMesh + MaterialPropertyBlock
/// </summary>
public class BlockBatchBuilder : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Mesh _mesh;
    [SerializeField] private Material _baseMaterial;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private Dictionary<BlockSpriteKey, int> _keyToSlot;
    private List<BatchLists> _batches;
    private int _batchCount;

    // Effect 전용
    private Dictionary<BlockSpriteKey, Material> _effectMaterials;
    private MaterialPropertyBlock _effectMpb;
    private static readonly int _colorID = Shader.PropertyToID("_Color");
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification()
    {
        De.IsNull(_mesh);
        De.IsNull(_baseMaterial);
    }

    public void Initialize()
    {
        _keyToSlot = new Dictionary<BlockSpriteKey, int>();
        _batches = new List<BatchLists>();
        _batchCount = 0;
        _effectMaterials = new Dictionary<BlockSpriteKey, Material>();
        _effectMpb = new MaterialPropertyBlock();
    }

    private int GetOrCreateSlot(BlockSpriteKey key, Sprite sprite)
    {
        if (_keyToSlot.TryGetValue(key, out int slot))
            return slot;
        Material mat = UGraphic.CreateMaterial(_baseMaterial, sprite);
        slot = _batches.Count;
        _batches.Add(new BatchLists(mat));
        _keyToSlot.Add(key, slot);
        _batchCount = _batches.Count;
        return slot;
    }

    private Material GetOrCreateEffectMaterial(BlockSpriteKey key, Sprite sprite)
    {
        if (_effectMaterials.TryGetValue(key, out Material mat))
            return mat;
        mat = UGraphic.CreateMaterial(_baseMaterial, sprite);
        mat.SetTexture("_BaseMap", sprite.texture);
        _effectMaterials.Add(key, mat);
        return mat;
    }

    private void AddMatrix(int slot, Matrix4x4 matrix)
    {
        List<List<Matrix4x4>> matrices = _batches[slot].matrices;
        List<Matrix4x4> curList = matrices[matrices.Count - 1];
        if (1000 <= curList.Count) {
            curList = new List<Matrix4x4>(1000);
            matrices.Add(curList);
        }
        curList.Add(matrix);
    }

    private void ClearAllBatches()
    {
        for (int i = 0; i < _batchCount; ++i) {
            List<List<Matrix4x4>> matrices = _batches[i].matrices;
            for (int j = 0; j < matrices.Count; ++j)
                matrices[j].Clear();
            while (matrices.Count > 1)
                matrices.RemoveAt(matrices.Count - 1);
        }
    }

    public void RunAfterFrame()
    {
        GameData game = GameData.ins;
        if (De.IsNull(game)) return;

        PoolManagement<BlockSingle> pool = game.BlockPool;
        BlockMap blockMap = game.Blocks;
        int capacity = pool.Capacity;

        ClearAllBatches();

        for (int adress = 0; adress < capacity; ++adress) {
            if (!pool.IsExist(adress))
                continue;

            ref readonly BlockSingle block = ref pool.Read(adress);
            if (block.IsVoid())
                continue;

            if (!game.BlockDatabase.TryGetValue(block.id, out SO_Block so))
                continue;

            Vector2 renderPos = blockMap.GetRenderPos(block.index, block.size, block.rotation);
            float baseX = renderPos.x;
            float baseY = renderPos.y;

            float blockAngle = UGrid.RotationToAngle(block.rotation);
            float bodyAngle = block.partAngle_1;
            float turretAngle = block.partAngle_2;
            float rotationAngle = block.partAngle_3;

            Vector3 scale = new Vector3(so.Size.x, so.Size.y, 1f);

            // 이펙트 투명도 계산 (삼각파: 0→1→0)
            float effectAlpha = 0f;
            float cycle = so.EffectCycleTime;
            if (cycle > 0f) {
                float t = block.effectTimer / cycle; // 0 ~ 2
                effectAlpha = (t <= 1f) ? t : 2f - t;
            }

            int spriteCount = so.SpriteCount;
            for (int si = 0; si < spriteCount; ++si) {
                SpriteInfo info = so.GetSpriteInfo(si);

                float posZ = -30f + info.offset.z;
                float offsetX = info.offset.x;
                float offsetY = info.offset.y;

                Quaternion rot;
                Vector3 pos;

                switch (info.type) {
                    case ESpriteType.Body:
                        rot = UGraphic.AngleToQuaternion(bodyAngle);
                        pos = UGraphic.RotateOffset(baseX, baseY, offsetX, offsetY, bodyAngle, posZ);
                        break;
                    case ESpriteType.Turret:
                        rot = UGraphic.AngleToQuaternion(turretAngle);
                        pos = UGraphic.RotateOffset(baseX, baseY, offsetX, offsetY, turretAngle, posZ);
                        break;
                    case ESpriteType.Rotation:
                        rot = UGraphic.AngleToQuaternion(rotationAngle);
                        pos = UGraphic.RotateOffset(baseX, baseY, offsetX, offsetY, rotationAngle, posZ);
                        break;
                    case ESpriteType.Effect:
                        // Effect는 개별 DrawMesh로 처리 (아래 별도)
                        DrawEffect(block, so, info, si, baseX, baseY, blockAngle, scale, effectAlpha);
                        continue; // 배치에 추가하지 않음
                    case ESpriteType.Static:
                    default:
                        rot = UGraphic.AngleToQuaternion(blockAngle);
                        pos = UGraphic.RotateOffset(baseX, baseY, offsetX, offsetY, blockAngle, posZ);
                        break;
                }

                BlockSpriteKey key = new BlockSpriteKey(block.id, si);
                int slot = GetOrCreateSlot(key, info.sprite);
                Matrix4x4 matrix = UGraphic.BuildMatrix(pos, rot, scale);
                AddMatrix(slot, matrix);
            }
        }

        // 배치 그리기 (Body, Turret, Rotation, Static)
        for (int i = 0; i < _batchCount; ++i) {
            Material mat = _batches[i].Mat;
            List<List<Matrix4x4>> matrices = _batches[i].matrices;
            for (int j = 0; j < matrices.Count; ++j) {
                if (matrices[j].Count <= 0) continue;
                Graphics.DrawMeshInstanced(_mesh, 0, mat, matrices[j]);
            }
        }
    }

    /// <summary>
    /// Effect 스프라이트를 개별 투명도로 렌더링합니다.
    /// </summary>
    private void DrawEffect(
        in BlockSingle block, SO_Block so, in SpriteInfo info, int spriteIndex,
        float baseX, float baseY, float blockAngle, Vector3 scale, float alpha)
    {
        float posZ = -30f + info.offset.z;
        Quaternion rot = UGraphic.AngleToQuaternion(blockAngle);
        Vector3 pos = UGraphic.RotateOffset(baseX, baseY, info.offset.x, info.offset.y, blockAngle, posZ);
        Matrix4x4 matrix = UGraphic.BuildMatrix(pos, rot, scale);

        BlockSpriteKey key = new BlockSpriteKey(block.id, spriteIndex);
        Material mat = GetOrCreateEffectMaterial(key, info.sprite);

        _effectMpb.SetColor(_colorID, new Color(1f, 1f, 1f, alpha));
        Graphics.DrawMesh(_mesh, matrix, mat, 0, null, 0, _effectMpb);
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\Block_Graphic\BlockGraphicManager.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 블록 그래픽 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 블록 그래픽 스크립트를 호출합니다.
/// </summary>
public class BlockGraphicManager : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private BlockBatchBuilder _blockBatchBuilder;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification()
    {
        De.IsNull(_blockBatchBuilder);
        _blockBatchBuilder.Verification();
    }

    public void DataBuilder()
    {

    }

    public void Initialize()
    {
        _blockBatchBuilder.Initialize();
    }

    public void RunBeforeFrame()
    {

    }

    public void RunAfterFrame()
    {
        _blockBatchBuilder.RunAfterFrame();
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\Camera\CameraManager.cs 
// ======================================================== 
 
using UnityEngine;
/// <summary>
/// 카메라 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 카메라 스크립트를 호출합니다.
/// </summary>
public class CameraManager : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private CameraTrackPlayer _minimapCamera;
    [SerializeField] private CameraTrackPlayer _playerCamera;
    [SerializeField] private CameraZoom _cameraZoom;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 인스펙터 유효성 검사
    public void Verification()
    {
        De.IsNull(_playerCamera);
        De.IsNull(_minimapCamera);
        De.IsNull(_cameraZoom);
        _playerCamera.Verification();
        _minimapCamera.Verification();
        _cameraZoom.Verification();
    }
    // 스크립트 내부 변수 초기화
    public void Initialize()
    {
        _playerCamera.Initialize();
        _minimapCamera.Initialize();
        _cameraZoom.Initialize();
    }
    // 외부에 전달할 데이터 생성
    public void DataBuilder()
    {

    }
    // 마스터 매니저의 Update() 에서 호출할 메서드
    public void RunBeforeFrame()
    {

    }
    // 마스터 매니저의 LateUpdate() 에서 호출할 메서드
    public void RunAfterFrame()
    {
        _playerCamera.RunAfter();
        _minimapCamera.RunAfter();
        _cameraZoom.RunAfterFrame();
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\Camera\CameraTrackPlayer.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 아무 오브젝트에 부착하는 스크립트입니다.
/// 카메라가 플레이어를 자동으로 추적합니다.
/// </summary>
public class CameraTrackPlayer : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Camera _camera;

    [Header("인스펙터 │ 매니저")]
    [SerializeField] private Transform _target;

    [Header("사용자 정의 설정")]
    [SerializeField] private float _zOffset = -100f;
    [SerializeField] private float _sharpness = 15f;
    [SerializeField] private float _outlineOffset = 1.5f;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private float _minX, _maxX;
    private float _minY, _maxY;
    private float _cameraSize;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void SetPlayer(Transform target) => _target = target;
    // Clamp한 목표 좌표를 반환합니다.
    private Vector3 BuildDesiredPos()
    {
        Vector3 desiredPos = _target.position;
        desiredPos.x = Mathf.Clamp(desiredPos.x, _minX, _maxX);
        desiredPos.y = Mathf.Clamp(desiredPos.y, _minY, _maxY);
        desiredPos.z = _zOffset;
        return desiredPos;
    }
    // 카메라의 위치를 플레이어에게 순간이동시킵니다.
    // Z 좌표와 회전 값을 초기화합니다.
    private void InitPos()
    {
        _camera.transform.position = BuildDesiredPos();
        _camera.transform.rotation = Quaternion.identity;
    }
    // 카메라의 위치를 플레이어에게 부드럽게 이동합니다.
    private void SharpnessPos()
    {

        Vector3 desiredPos = BuildDesiredPos();
        float t = UMath.GetSmoothT(_sharpness, Time.deltaTime);         
        _camera.transform.position = Vector3.Lerp(_camera.transform.position, desiredPos, t);
    }

    /// <summary>
    /// Clamp하기 위한 값을 변수에 저장합니다.
    /// </summary>
    private void CacheCameraClamp()
    {
        var tileMap = GameData.ins.TileMap;
        float outlineWall = (float)tileMap.OutlineWall;
        float cameraW = _camera.orthographicSize * _camera.aspect - _outlineOffset;
        float cameraH = _camera.orthographicSize - _outlineOffset;

        _minX = outlineWall + cameraW;
        _maxX = (float)tileMap.Width - outlineWall - cameraW;
        _minY = outlineWall + cameraH;
        _maxY = (float)tileMap.Height - outlineWall - cameraH;
        _cameraSize = _camera.orthographicSize;
        //De.Print($"카메라 Clamp 값을 캐싱했습니다. (cameraW = {cameraW}, cameraH = {cameraH})");
    }
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메시지 함수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification()
    {
        De.IsNull(_camera);
    }
    public void Initialize()
    {
        De.IsTrue(GameData.ins.TileMap.IsInvalid());

        CacheCameraClamp();
        InitPos();
    }
    private bool _targetLost = false;
    public void RunAfter()
    {
        if (De.IsNull(_camera)) return;

        // 카메라 크기 달라졌으면 다시 캐싱
        if (_cameraSize != _camera.orthographicSize) {
            CacheCameraClamp();
            InitPos();
        }

        // 카메라 지수 보간
        if (_targetLost == false) {
            if (_target == null) {
                _targetLost = true;
            } else {
                SharpnessPos();
            }
        }
        // 목표 재발견, 카메라 순간이동
        else if (_target != null) {
            _targetLost = false;
            InitPos();
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\Camera\CameraZoom.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

/// <summary>
/// 아무 오브젝트에 부착하는 스크립트입니다.
/// 플레이어의 마우스 휠을 인식해서 카메라의 크기를 줄이거나 늘립니다.
/// </summary>
public class CameraZoom : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Camera _camera;
    [SerializeField] private PlayerInput _input;

    [Header("사용자 정의 설정")]
    [SerializeField] private float _zoomSpeed = 2f;
    [SerializeField] private float _zoomSharpness = 12f;
    [SerializeField] private float _minSize = 3f;
    [SerializeField] private float _maxSize = 10f;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    float _desiredSize;
    List<SelectedBlock> _selected;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification()
    {
        De.IsNull(_camera);
        De.IsNull(_input);
    }
    public void Initialize()
    {
        // 캐싱
        _selected = GameData.ins.Player.selecteds;
        _desiredSize = (_minSize + _maxSize) * 0.5f;
        // 이벤트 구독
        _input.OnScrollUp += ZoomIn;
        _input.OnScrollDown += ZoomOut;
    }
    public void RunAfterFrame()
    {
        float t = UMath.GetSmoothT(_zoomSharpness, Time.deltaTime);
        _camera.orthographicSize = Mathf.Lerp(_camera.orthographicSize, _desiredSize, t);
    }
    private void ZoomIn()
    {
        // UI에 위치, 블록 선택 상태
        if (EventSystem.current.IsPointerOverGameObject())
            return;
        if (0 < _selected.Count)
            return;
        // orthographicSize를 줄이면 확대
        _desiredSize -= _zoomSpeed;
        _desiredSize = Mathf.Clamp(_desiredSize, _minSize, _maxSize);
    }
    private void ZoomOut()
    {
        // UI에 위치, 블록 선택 상태
        if (EventSystem.current.IsPointerOverGameObject())
            return;
        if (0 < _selected.Count)
            return;
        // orthographicSize를 늘리면 축소
        _desiredSize += _zoomSpeed;
        _desiredSize = Mathf.Clamp(_desiredSize, _minSize, _maxSize);
    }
    #endregion

    private void OnDestroy()
    {
        _input.OnScrollUp -= ZoomIn;
        _input.OnScrollDown -= ZoomOut;
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\Effect_Graphic\EffectGraphicManager.cs 
// ======================================================== 
 
﻿using UnityEngine;
/// <summary>
/// 이펙트 그래픽 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 이펙트 그래픽 스크립트를 호출합니다.
/// </summary>
public class EffectGraphicManager : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private SoundAdmin _soundAdmin;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓

    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 인스펙터 유효성 검사
    public void Verification()
    {
        _soundAdmin.Verification();
    }
    // 스크립트 내부 변수 초기화
    public void Initialize()
    {
        _soundAdmin.Initialized();
    }
    // 외부에 전달할 데이터 생성
    public void DataBuilder()
    {
        _soundAdmin.DataBuilder();
    }
    // 마스터 매니저의 Update() 에서 호출할 메서드
    public void RunBeforeFrame()
    {

    }
    // 마스터 매니저의 LateUpdate() 에서 호출할 메서드
    public void RunAfterFrame()
    {

    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\Effect_Graphic\SoundAdmin.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;
public enum ESound
{
    None = 0,
    BlockBuild_1 = 1,
    BlockBuild_2 = 2,
    BlockBuild_3 = 3,
    BlockDestory_1 = 4,
    BlockDestory_2 = 5,
    BlockDestory_3 = 6
}
/// <summary>
/// 사운드 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 등록된 사운드 클립을 이름으로 검색하여 재생합니다.
/// </summary>
public class SoundAdmin : MonoBehaviour
{
    [System.Serializable]
    public struct ClipPair
    {
        public ESound name;
        public AudioClip clip;
    }
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private ClipPair[] _clipPairs;
    [SerializeField] private AudioSource _source;
    [Header("사용자 정의 설정")]
    [SerializeField] private float _volume = 1f;
    [SerializeField] private bool _usePitch = true; // 사운드 울리기
    [SerializeField] private Vector2 _pitchRange = new Vector2(0.95f, 1.05f);
    #endregion
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private Dictionary<ESound, AudioClip> _clips;
    #endregion
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 인스펙터 유효성 검사
    public void Verification()
    {
        De.IsNull(_source);
        De.IsNull(_clipPairs);
    }

    public void Initialized()
    {
        // 건설 사운드
        PlayerArchitect.OnBuildEffect += (pos, sx, sy) => {
            if (sx <= 1.001f) PlaySound(ESound.BlockBuild_1);
            else if (sx <= 2.001f) PlaySound(ESound.BlockBuild_2);
            else PlaySound(ESound.BlockBuild_3);
        };

        // 철거 사운드
        PlayerArchitect.OnDestroyEffect += (pos, sx, sy) => {
            if (sx <= 1.001f) PlaySound(ESound.BlockDestory_1);
            else if (sx <= 2.001f) PlaySound(ESound.BlockDestory_2);
            else PlaySound(ESound.BlockDestory_3);
        };
    }

    // 외부에 전달할 데이터 생성
    public void DataBuilder()
    {
        // 딕셔너리로 변경하기
        int length = _clipPairs.Length;
        _clips = new Dictionary<ESound, AudioClip>(length);
        for (int i = 0; i < length; ++i) {
            if (_clipPairs[i].clip == null)
                continue;
            _clips.Add(_clipPairs[i].name, _clipPairs[i].clip);
        }
    }
    /// <summary>
    /// 지정한 사운드를 한 번 재생합니다.
    /// </summary>
    public void PlaySound(ESound sound)
    {
        if (!_clips.TryGetValue(sound, out AudioClip clip))
            return;
        if (_usePitch) {
            _source.pitch = Random.Range(_pitchRange.x, _pitchRange.y);
        } else {
            _source.pitch = 1f;
        }
        _source.PlayOneShot(clip, _volume);
    }
    /// <summary>
    /// 지정한 사운드를 볼륨을 지정하여 한 번 재생합니다.
    /// </summary>
    public void PlaySound(ESound sound, float volumeScale)
    {
        if (!_clips.TryGetValue(sound, out AudioClip clip))
            return;
        if (_usePitch) {
            _source.pitch = Random.Range(_pitchRange.x, _pitchRange.y);
        } else {
            _source.pitch = 1f;
        }
        _source.PlayOneShot(clip, volumeScale);
    }
    #endregion
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메시지 함수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\Tile_Graphic\TileGraphicManager.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 타일 그래픽 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 타일 그래픽 스크립트를 호출합니다.
/// </summary>
public class TileGraphicManager : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private TilePainter _tilePainter;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification()
    {
        De.IsNull(_tilePainter);
        _tilePainter.Verification();
    }

    public void DataBuilder()
    {
        _tilePainter.DataBuilder();
    }

    public void Initialize()
    {

    }

    public void RunBeforeFrame()
    {

    }

    public void RunAfterFrame()
    {
        _tilePainter.RunAfterFrame();
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\Tile_Graphic\TilePainter.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 타일 그래픽 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// DataBuilder에서 타일맵을 1회 순회하여 정적 렌더링 데이터를 구성하고,
/// RunAfterFrame에서 DrawMeshInstanced로 매 프레임 그립니다.
/// </summary>
public class TilePainter : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Mesh _mesh;
    [SerializeField] private Material _baseMaterial;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private BatchLists[] _batches;
    private int _batchCount;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification()
    {
        De.IsNull(_mesh);
        De.IsNull(_baseMaterial);
    }

    /// <summary>
    /// 타일맵을 1회 순회하여 정적 렌더링 데이터를 구성합니다.
    /// 맵 생성 직후 한 번만 호출합니다.
    /// </summary>
    public void DataBuilder()
    {
        GameData game = GameData.ins;
        TileMap map = game.TileMap;
        var tileDatabase = game.TileDatabase;
        int width = map.Width;
        int length = width * map.Height;

        // 타일 종류 → 배치 슬롯 인덱스
        Dictionary<ETile, int> tileToSlot = new Dictionary<ETile, int>();
        List<BatchLists> batchList = new List<BatchLists>();

        for (int index = 0; index < length; ++index) {
            ref readonly TileSingle tile = ref map.Read(index);
            if (tile.IsVoid())
                continue;
            ETile id = tile.id;

            // 슬롯 없으면 생성
            if (!tileToSlot.TryGetValue(id, out int slot)) {
                slot = batchList.Count;
                tileToSlot.Add(id, slot);
                Material mat = UGraphic.CreateMaterial(_baseMaterial, tileDatabase[id].GetSprite(0));
                batchList.Add(new BatchLists(mat));
            }

            // 행렬 생성 (셀 중심)
            (int gx, int gy) = UGrid.IndexToGrid(index, width);
            Vector3 pos = new Vector3(gx + 0.5f, gy + 0.5f, 0f);
            Matrix4x4 matrix = Matrix4x4.TRS(pos, Quaternion.identity, Vector3.one);

            // 배치에 추가
            BatchLists batch = batchList[slot];
            List<Matrix4x4> curList = batch.matrices[batch.matrices.Count - 1];
            if (1000 <= curList.Count) {
                curList = new List<Matrix4x4>(1000);
                batch.matrices.Add(curList);
            }
            curList.Add(matrix);
        }

        _batches = batchList.ToArray();
        _batchCount = _batches.Length;
        De.Print($"타일 렌더링 데이터를 빌드했습니다. (종류 {_batchCount}개)");
    }

    /// <summary>
    /// 매 프레임 정적 타일 데이터를 DrawMeshInstanced로 그립니다.
    /// </summary>
    public void RunAfterFrame()
    {
        for (int i = 0; i < _batchCount; ++i) {
            List<List<Matrix4x4>> matrices = _batches[i].matrices;
            Material mat = _batches[i].Mat;
            for (int j = 0; j < matrices.Count; ++j) {
                Graphics.DrawMeshInstanced(_mesh, 0, mat, matrices[j]);
            }
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\User_Interface\BuildEffectPainter.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 유저 인터페이스 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 건설/철거 완료 시 테두리 사각형이 블록 크기에서 시작하여 커지며 사라지는 이펙트를 표시합니다.
/// PlayerArchitect.OnBuildEffect / OnDestroyEffect 이벤트를 구독합니다.
/// </summary>
public class BuildEffectPainter : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("사용자 정의 설정")]
    [SerializeField] private Color _buildColor = new Color(1f, 0.85f, 0.3f, 0.8f);
    [SerializeField] private Color _destroyColor = new Color(1f, 0.2f, 0.2f, 0.8f);
    [SerializeField] private float _duration = 0.3f;
    [SerializeField] private float _expandSize = 1.0f;
    [SerializeField] private float _lineWidth = 0.06f;
    [SerializeField] private float _zDepth = -35f;
    [SerializeField] private int _poolSize = 12;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private struct EffectInstance
    {
        public LineRenderer line;
        public float startTime;
        public Vector2 center;
        public float startHalfW;  // 블록 절반 너비
        public float startHalfH;  // 블록 절반 높이
        public Color color;
        public bool active;
    }

    private EffectInstance[] _pool;
    private int _nextIndex;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification() { }

    public void Initialize()
    {
        Material mat = new Material(Shader.Find("Sprites/Default"));

        _pool = new EffectInstance[_poolSize];
        for (int i = 0; i < _poolSize; ++i) {
            GameObject go = new GameObject($"BuildEffect_{i}");
            go.transform.SetParent(transform);

            LineRenderer line = go.AddComponent<LineRenderer>();
            line.useWorldSpace = true;
            line.loop = true;
            line.positionCount = 4;
            line.startWidth = _lineWidth;
            line.endWidth = _lineWidth;
            line.sortingOrder = 102;
            line.material = mat;
            line.enabled = false;

            _pool[i] = new EffectInstance
            {
                line = line,
                active = false
            };
        }
        _nextIndex = 0;

        PlayerArchitect.OnBuildEffect += OnBuild;
        PlayerArchitect.OnDestroyEffect += OnDestroye;
    }

    private void OnDisable()
    {
        PlayerArchitect.OnBuildEffect -= OnBuild;
        PlayerArchitect.OnDestroyEffect -= OnDestroye;
    }

    private void OnBuild(Vector2 center, float sizeX, float sizeY)
    {
        Spawn(center, sizeX, sizeY, _buildColor);
    }

    private void OnDestroye(Vector2 center, float sizeX, float sizeY)
    {
        Spawn(center, sizeX, sizeY, _destroyColor);
    }

    private void Spawn(Vector2 center, float sizeX, float sizeY, Color color)
    {
        ref EffectInstance inst = ref _pool[_nextIndex];
        inst.center = center;
        inst.startHalfW = sizeX * 0.5f;
        inst.startHalfH = sizeY * 0.5f;
        inst.startTime = Time.time;
        inst.color = color;
        inst.active = true;
        inst.line.enabled = true;
        inst.line.startColor = color;
        inst.line.endColor = color;
        _nextIndex = (_nextIndex + 1) % _poolSize;
    }

    public void RunAfterFrame()
    {
        float now = Time.time;
        float z = _zDepth;

        for (int i = 0; i < _poolSize; ++i) {
            ref EffectInstance inst = ref _pool[i];
            if (!inst.active)
                continue;

            float elapsed = now - inst.startTime;
            if (elapsed >= _duration) {
                inst.active = false;
                inst.line.enabled = false;
                continue;
            }

            float t = elapsed / _duration;
            // 크기: 블록 크기에서 expandSize만큼 추가로 커짐
            float expand = _expandSize * t;
            float hw = inst.startHalfW + expand;
            float hh = inst.startHalfH + expand;
            // 알파: 1 → 0
            Color c = inst.color;
            c.a = Mathf.Lerp(inst.color.a, 0f, t);
            inst.line.startColor = c;
            inst.line.endColor = c;

            float cx = inst.center.x;
            float cy = inst.center.y;
            inst.line.SetPosition(0, new Vector3(cx - hw, cy - hh, z));
            inst.line.SetPosition(1, new Vector3(cx + hw, cy - hh, z));
            inst.line.SetPosition(2, new Vector3(cx + hw, cy + hh, z));
            inst.line.SetPosition(3, new Vector3(cx - hw, cy + hh, z));
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\User_Interface\CopyAreaPainter.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 유저 인터페이스 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// F키 드래그 중 복사 영역을 노란색 테두리 사각형으로 표시합니다.
/// </summary>
public class CopyAreaPainter : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("사용자 정의 설정")]
    [SerializeField] private Color _borderColor = new Color(1f, 0.9f, 0.3f, 0.7f);
    [SerializeField] private float _lineWidth = 0.08f;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private LineRenderer _line;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification() { }

    public void Initialize()
    {
        _line = gameObject.AddComponent<LineRenderer>();
        _line.useWorldSpace = true;
        _line.loop = true;
        _line.positionCount = 4;
        _line.startWidth = _lineWidth;
        _line.endWidth = _lineWidth;
        _line.sortingOrder = 100;
        _line.material = new Material(Shader.Find("Sprites/Default"));
        _line.startColor = _borderColor;
        _line.endColor = _borderColor;
        _line.enabled = false;
    }

    public void RunAfterFrame()
    {
        GameData game = GameData.ins;
        if (game == null || game.Player == null) {
            _line.enabled = false;
            return;
        }

        PlayerSingle player = game.Player;
        if (!player.copyActive) {
            _line.enabled = false;
            return;
        }

        _line.enabled = true;

        float left = player.copyMinX;
        float right = player.copyMaxX + 1f;
        float bottom = player.copyMinY;
        float top = player.copyMaxY + 1f;

        _line.SetPosition(0, new Vector3(left, bottom, 0f));
        _line.SetPosition(1, new Vector3(right, bottom, 0f));
        _line.SetPosition(2, new Vector3(right, top, 0f));
        _line.SetPosition(3, new Vector3(left, top, 0f));
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\User_Interface\DemolishAreaPainter.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 유저 인터페이스 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 우클릭 드래그 중 철거 영역을 빨간 테두리 사각형으로 표시합니다.
/// LineRenderer를 사용하여 4개 꼭짓점을 잇는 닫힌 사각형을 그립니다.
/// </summary>
public class DemolishAreaPainter : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("사용자 정의 설정")]
    [SerializeField] private Color _borderColor = new Color(1f, 0.2f, 0.2f, 0.7f);
    [SerializeField] private float _lineWidth = 0.08f;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private LineRenderer _line;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification() { }

    public void Initialize()
    {
        _line = gameObject.AddComponent<LineRenderer>();
        _line.useWorldSpace = true;
        _line.loop = true;
        _line.positionCount = 4;
        _line.startWidth = _lineWidth;
        _line.endWidth = _lineWidth;
        _line.sortingOrder = 100;
        // 단색 머티리얼 (Sprites/Default는 유니티 내장)
        _line.material = new Material(Shader.Find("Sprites/Default"));
        _line.startColor = _borderColor;
        _line.endColor = _borderColor;
        _line.enabled = false;
    }

    public void RunAfterFrame()
    {
        GameData game = GameData.ins;
        if (game == null || game.Player == null) {
            _line.enabled = false;
            return;
        }

        PlayerSingle player = game.Player;
        if (!player.demolishActive) {
            _line.enabled = false;
            return;
        }

        _line.enabled = true;

        // 그리드 좌표 → 월드 좌표
        // 셀 (minX, minY) ~ (maxX, maxY) 영역의 테두리
        // 셀의 왼쪽 아래가 정수 좌표이므로, 영역의 외곽은 +1
        float left = player.demolishMinX;
        float right = player.demolishMaxX + 1f;
        float bottom = player.demolishMinY;
        float top = player.demolishMaxY + 1f;
        float z = 0f; // LineRenderer는 sortingOrder로 깊이 제어

        _line.SetPosition(0, new Vector3(left, bottom, z));
        _line.SetPosition(1, new Vector3(right, bottom, z));
        _line.SetPosition(2, new Vector3(right, top, z));
        _line.SetPosition(3, new Vector3(left, top, z));
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\User_Interface\DesignBatchBuilder.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 유저 인터페이스 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 매 프레임 designs를 순회하여 디자인 블록(건설 예정)의 렌더링 배치 데이터를 구성합니다.
/// BatchLists 기반으로 키 조회 없이 인덱스로 직접 접근합니다.
/// </summary>
public class DesignBatchBuilder : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Mesh _mesh;
    [SerializeField] private Material _baseMaterial;

    [Header("사용자 정의 설정")]
    [SerializeField, Range(0.1f, 1f)] private float _alpha = 0.75f;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private Dictionary<BlockSpriteKey, int> _keyToSlot;
    private List<BatchLists> _batches;
    private int _batchCount;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification()
    {
        De.IsNull(_mesh);
        De.IsNull(_baseMaterial);
    }

    public void Initialize()
    {
        _keyToSlot = new Dictionary<BlockSpriteKey, int>();
        _batches = new List<BatchLists>();
        _batchCount = 0;
    }

    private int GetOrCreateSlot(BlockSpriteKey key, Sprite sprite)
    {
        if (_keyToSlot.TryGetValue(key, out int slot))
            return slot;
        Material mat = UGraphic.CreateMaterial(_baseMaterial, sprite);
        Color c = mat.color;
        c.a = _alpha;
        mat.color = c;
        slot = _batches.Count;
        _batches.Add(new BatchLists(mat));
        _keyToSlot.Add(key, slot);
        _batchCount = _batches.Count;
        return slot;
    }

    private void AddMatrix(int slot, Matrix4x4 matrix)
    {
        List<List<Matrix4x4>> matrices = _batches[slot].matrices;
        List<Matrix4x4> curList = matrices[matrices.Count - 1];
        if (1000 <= curList.Count) {
            curList = new List<Matrix4x4>(1000);
            matrices.Add(curList);
        }
        curList.Add(matrix);
    }

    private void ClearAllBatches()
    {
        for (int i = 0; i < _batchCount; ++i) {
            List<List<Matrix4x4>> matrices = _batches[i].matrices;
            for (int j = 0; j < matrices.Count; ++j)
                matrices[j].Clear();
            while (matrices.Count > 1)
                matrices.RemoveAt(matrices.Count - 1);
        }
    }

    public void RunAfterFrame()
    {
        GameData game = GameData.ins;
        if (De.IsNull(game)) return;
        if (De.IsNull(game.Player)) return;

        var designs = game.Player.designs;
        ClearAllBatches();

        if (designs.Count <= 0)
            return;

        BlockMap blockMap = game.Blocks;

        foreach (var kvp in designs) {
            BuildOrder order = kvp.Value;
            if (order.type != EOrderType.Build)
                continue;

            EBlock id = order.id;
            if (!game.BlockDatabase.TryGetValue(id, out SO_Block so))
                continue;

            Vector2Int size = new Vector2Int((int)so.Size.x, (int)so.Size.y);
            Vector2 renderPos = blockMap.GetRenderPos(order.index, size, order.rotation);
            float baseX = renderPos.x;
            float baseY = renderPos.y;
            float blockAngle = UGrid.RotationToAngle(order.rotation);

            // 모든 스프라이트에 블록 크기 적용
            Vector3 scale = new Vector3(so.Size.x, so.Size.y, 1f);

            int spriteCount = so.SpriteCount;
            for (int si = 0; si < spriteCount; ++si) {
                SpriteInfo info = so.GetSpriteInfo(si);
                BlockSpriteKey key = new BlockSpriteKey(id, si);
                int slot = GetOrCreateSlot(key, info.sprite);

                float posZ = -30.5f + info.offset.z;

                Quaternion rot;
                switch (info.type) {
                    case ESpriteType.Body:
                    case ESpriteType.Turret:
                    case ESpriteType.Rotation:
                        rot = UGraphic.AngleToQuaternion(blockAngle);
                        break;
                    default:
                        rot = Quaternion.identity;
                        break;
                }

                Vector3 pos = UGraphic.RotateOffset(baseX, baseY, info.offset.x, info.offset.y, blockAngle, posZ);
                Matrix4x4 matrix = UGraphic.BuildMatrix(pos, rot, scale);
                AddMatrix(slot, matrix);
            }
        }

        // 그리기
        for (int i = 0; i < _batchCount; ++i) {
            Material mat = _batches[i].Mat;
            List<List<Matrix4x4>> matrices = _batches[i].matrices;
            for (int j = 0; j < matrices.Count; ++j) {
                if (matrices[j].Count <= 0) continue;
                Graphics.DrawMeshInstanced(_mesh, 0, mat, matrices[j]);
            }
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\User_Interface\DestoryMarkerPainter.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 유저 인터페이스 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// designs에서 EOrderType.Destroy인 블록에 빨간색 테두리를 매 프레임 그립니다.
/// LineRenderer 풀링으로 동적 개수를 처리합니다.
/// </summary>
public class DestroyMarkerPainter : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("사용자 정의 설정")]
    [SerializeField] private Color _markerColor = new Color(1f, 0.2f, 0.2f, 0.6f);
    [SerializeField] private float _lineWidth = 0.06f;
    [SerializeField] private float _zDepth = -34f;
    [SerializeField] private int _initialPoolSize = 16;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private List<LineRenderer> _pool;
    private Material _mat;
    private int _activeCount;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification() { }

    public void Initialize()
    {
        _mat = new Material(Shader.Find("Sprites/Default"));
        _pool = new List<LineRenderer>(_initialPoolSize);
        _activeCount = 0;
        for (int i = 0; i < _initialPoolSize; ++i)
            _pool.Add(CreateLine(i));
    }

    private LineRenderer CreateLine(int idx)
    {
        GameObject go = new GameObject($"DestroyMarker_{idx}");
        go.transform.SetParent(transform);
        LineRenderer line = go.AddComponent<LineRenderer>();
        line.useWorldSpace = true;
        line.loop = true;
        line.positionCount = 4;
        line.startWidth = _lineWidth;
        line.endWidth = _lineWidth;
        line.sortingOrder = 100;
        line.material = _mat;
        line.startColor = _markerColor;
        line.endColor = _markerColor;
        line.enabled = false;
        return line;
    }

    private LineRenderer GetLine(int index)
    {
        while (index >= _pool.Count)
            _pool.Add(CreateLine(_pool.Count));
        return _pool[index];
    }

    public void RunAfterFrame()
    {
        GameData game = GameData.ins;
        if (game == null || game.Player == null) {
            HideAll();
            return;
        }

        var designs = game.Player.designs;
        BlockMap blockMap = game.Blocks;
        Dictionary<EBlock, SO_Block> soDb = game.BlockDatabase;

        int used = 0;

        foreach (var kvp in designs) {
            BuildOrder order = kvp.Value;
            if (order.type != EOrderType.Destroy)
                continue;

            int centerIndex = order.index;

            // 블록 크기 → 렌더링 영역 계산
            float sizeX = 1f;
            float sizeY = 1f;
            if (soDb.TryGetValue(order.id, out SO_Block so)) {
                sizeX = so.Size.x;
                sizeY = so.Size.y;
            }
            Vector2Int size = new Vector2Int((int)sizeX, (int)sizeY);
            Vector2 renderPos = blockMap.GetRenderPos(centerIndex, size, order.rotation);

            float cx = renderPos.x;
            float cy = renderPos.y;
            // 회전 시 시각적 크기 스왑
            float hw, hh;
            if (order.rotation == ERotation.Right || order.rotation == ERotation.Left) {
                hw = sizeY * 0.5f;
                hh = sizeX * 0.5f;
            } else {
                hw = sizeX * 0.5f;
                hh = sizeY * 0.5f;
            }

            float z = _zDepth;
            LineRenderer line = GetLine(used);
            line.enabled = true;
            line.SetPosition(0, new Vector3(cx - hw, cy - hh, z));
            line.SetPosition(1, new Vector3(cx + hw, cy - hh, z));
            line.SetPosition(2, new Vector3(cx + hw, cy + hh, z));
            line.SetPosition(3, new Vector3(cx - hw, cy + hh, z));
            ++used;
        }

        // 사용하지 않은 LineRenderer 비활성화
        for (int i = used; i < _activeCount; ++i) {
            if (i < _pool.Count)
                _pool[i].enabled = false;
        }
        _activeCount = used;
    }

    private void HideAll()
    {
        for (int i = 0; i < _activeCount; ++i) {
            if (i < _pool.Count)
                _pool[i].enabled = false;
        }
        _activeCount = 0;
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\User_Interface\SelectedBatchBuilder.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 유저 인터페이스 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 매 프레임 selecteds(List)를 순회하여 반투명 블록의 배치 데이터를 구성합니다.
/// </summary>
public class SelectedBatchBuilder : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Material _baseMaterial;

    [Header("사용자 정의 설정")]
    [SerializeField, Range(0.1f, 1f)] private float _alpha = 0.5f;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private Dictionary<BlockSpriteKey, Material> _materialCache;
    private Dictionary<EBlock, SO_Block> _soCache;
    private Dictionary<BlockSpriteKey, List<List<Matrix4x4>>> _batchMap;
    private List<BlockSpriteKey> _activeKeys;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 접근자 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public Dictionary<BlockSpriteKey, Material> MaterialCache => _materialCache;
    public Dictionary<BlockSpriteKey, List<List<Matrix4x4>>> BatchMap => _batchMap;
    public List<BlockSpriteKey> ActiveKeys => _activeKeys;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification()
    {
        De.IsNull(_baseMaterial);
    }

    public void Initialize()
    {
        _materialCache = new Dictionary<BlockSpriteKey, Material>();
        _soCache = new Dictionary<EBlock, SO_Block>();
        _batchMap = new Dictionary<BlockSpriteKey, List<List<Matrix4x4>>>();
        _activeKeys = new List<BlockSpriteKey>();
    }

    private SO_Block GetSO(EBlock id)
    {
        if (_soCache.TryGetValue(id, out SO_Block so))
            return so;
        if (!GameData.ins.BlockDatabase.TryGetValue(id, out so))
            return null;
        _soCache.Add(id, so);
        return so;
    }

    private Material GetOrCreateMaterial(BlockSpriteKey key, Sprite sprite)
    {
        if (_materialCache.TryGetValue(key, out Material mat))
            return mat;
        if (sprite == null)
            return null;
        mat = UGraphic.CreateMaterial(_baseMaterial, sprite);
        Color color = mat.color;
        color.a = _alpha;
        mat.color = color;
        _materialCache.Add(key, mat);
        return mat;
    }

    /// <summary>
    /// selected 전용 렌더링 좌표 계산.
    /// BlockMap.GetRenderPos는 인덱스 기반이라 맵 밖에서 사용할 수 없으므로,
    /// 그리드 좌표(float)로부터 직접 계산합니다.
    /// </summary>
    private static Vector2 GetSelectedRenderPos(float gx, float gy, Vector2Int size, ERotation rotation)
    {
        int sizeX = size.x;
        int sizeY = size.y;
        switch (rotation) {
            case ERotation.Up:
                return new Vector2(gx + sizeX * 0.5f, gy + sizeY * 0.5f);
            case ERotation.Right:
                return new Vector2(gx + sizeY * 0.5f, gy - sizeX * 0.5f);
            case ERotation.Down:
                return new Vector2(gx - sizeX * 0.5f, gy - sizeY * 0.5f);
            case ERotation.Left:
                return new Vector2(gx - sizeY * 0.5f, gy + sizeX * 0.5f);
            default:
                return new Vector2(gx + sizeX * 0.5f, gy + sizeY * 0.5f);
        }
    }

    /// <summary>
    /// 매 프레임 selecteds를 순회하여 렌더링 배치 데이터를 재구성합니다.
    /// </summary>
    public void RunAfterFrame()
    {
        GameData game = GameData.ins;
        if (De.IsNull(game)) return;
        if (De.IsNull(game.Player)) return;

        List<SelectedBlock> selecteds = game.Player.selecteds;
        int count = selecteds.Count;

        UGraphic.ClearBatches(_batchMap, _activeKeys);

        if (count <= 0)
            return;

        Vector2 cursor = game.Player.CursorInGrid;
        float cursorX = cursor.x;
        float cursorY = cursor.y;

        // 드래그 타일링에서는 모든 selected가 같은 id → SO 1번만 조회
        EBlock lastId = EBlock.None;
        SO_Block lastSO = null;
        float lastSizeX = 0f;
        float lastSizeY = 0f;
        Vector2Int lastSize = Vector2Int.zero;
        int lastSpriteCount = 0;

        for (int i = 0; i < count; ++i) {
            SelectedBlock sel = selecteds[i];
            if (sel.id == EBlock.None)
                continue;

            // SO 캐싱 (같은 id가 연속되면 Dictionary 조회 스킵)
            if (sel.id != lastId) {
                lastId = sel.id;
                lastSO = GetSO(sel.id);
                if (lastSO == null) continue;
                lastSizeX = lastSO.Size.x;
                lastSizeY = lastSO.Size.y;
                lastSize = new Vector2Int((int)lastSizeX, (int)lastSizeY);
                lastSpriteCount = lastSO.SpriteCount;
            }
            if (lastSO == null) continue;

            // 그리드 좌표 (정수로 스냅)
            float gx = Mathf.Floor(cursorX + sel.offsetX);
            float gy = Mathf.Floor(cursorY + sel.offsetY);

            // 렌더링 중심 (맵 밖이어도 계산 가능)
            Vector2 renderPos = GetSelectedRenderPos(gx, gy, lastSize, sel.rotation);
            float baseX = renderPos.x;
            float baseY = renderPos.y;
            float blockAngle = UGrid.RotationToAngle(sel.rotation);

            for (int si = 0; si < lastSpriteCount; ++si) {
                SpriteInfo info = lastSO.GetSpriteInfo(si);
                BlockSpriteKey spriteKey = new BlockSpriteKey(sel.id, si);

                GetOrCreateMaterial(spriteKey, info.sprite);

                float posZ = -31f + info.offset.z;

                Quaternion rot;
                switch (info.type) {
                    case ESpriteType.Body:
                    case ESpriteType.Turret:
                    case ESpriteType.Rotation:
                        rot = UGraphic.AngleToQuaternion(blockAngle);
                        break;
                    default:
                        rot = Quaternion.identity;
                        break;
                }

                Vector3 pos = UGraphic.RotateOffset(baseX, baseY, info.offset.x, info.offset.y, blockAngle, posZ);
                Vector3 scale = new Vector3(lastSizeX, lastSizeY, 1f);
                Matrix4x4 matrix = UGraphic.BuildMatrix(pos, rot, scale);
                UGraphic.AddMatrix(_batchMap, _activeKeys, spriteKey, matrix);
            }
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\User_Interface\SelectedPainter.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 유저 인터페이스 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// SelectedBatchBuilder가 구성한 배치 데이터를 DrawMeshInstanced로 그립니다.
/// </summary>
public class SelectedPainter : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Mesh _mesh;
    [SerializeField] private SelectedBatchBuilder _batchBuilder;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification()
    {
        De.IsNull(_mesh);
        De.IsNull(_batchBuilder);
    }

    public void RunAfterFrame()
    {
        UGraphic.DrawBatches(
            _mesh,
            _batchBuilder.BatchMap,
            _batchBuilder.ActiveKeys,
            _batchBuilder.MaterialCache
        );
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\User_Interface\UIBuildButton.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 건설 UI의 블록 버튼에 부착하는 C# 스크립트입니다.
/// 버튼을 클릭하면 해당 블록을 플레이어의 selectedBlockList에 등록합니다.
/// </summary>
public class UIBuildButton : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("블록 설정")]
    [SerializeField] private EBlock _blockID;
    #endregion

    List<SelectedBlock> _selecteds;

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 스크립트 내부 변수 초기화
    public void Initialize()
    {
        var game = GameData.ins;
        if (De.IsNull(game)) return;
        if (De.IsNull(game.Player)) return;
        _selecteds = game.Player.selecteds;
    }

    /// <summary>
    /// 기존 선택을 초기화하고, 해당 블록을 하나 선택합니다.
    /// </summary>
    public void OnClickSelect()
    {
        // 기존 선택 초기화
        _selecteds.Clear();
        // 블록 1개 선택
        SelectedBlock selected = new SelectedBlock(0f, 0f, _blockID, ERotation.Up);
        _selecteds.Add(selected);
        De.Print($"블록({_blockID})을 선택했습니다.");
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Graphic\User_Interface\UserInterfaceManager.cs 
// ======================================================== 
 
﻿using UnityEngine;
/// <summary>
/// 유저 인터페이스 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 유저 인터페이스 및 가상 블록 스크립트를 호출합니다.
/// </summary>
public class UserInterfaceManager : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private UIBuildButton[] _uiBuildButton;
    [SerializeField] private SelectedBatchBuilder _selectedBatchBuilder;
    [SerializeField] private SelectedPainter _selectedPainter;
    [SerializeField] private DesignBatchBuilder _designBatchBuilder;
    [SerializeField] private DemolishAreaPainter _demolishAreaPainter;
    [SerializeField] private BuildEffectPainter _buildEffectPainter;
    [SerializeField] private DestroyMarkerPainter _destroyMarkerPainter;
    [SerializeField] private CopyAreaPainter _copyAreaPainter;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 인스펙터 유효성 검사
    public void Verification()
    {
        De.IsNull(_uiBuildButton);
        for (int i = 0; i < _uiBuildButton.Length; ++i) {
            De.IsNull(_uiBuildButton[i]);
        }
        De.IsNull(_selectedBatchBuilder);
        De.IsNull(_selectedPainter);
        De.IsNull(_designBatchBuilder);
        De.IsNull(_demolishAreaPainter);
        De.IsNull(_buildEffectPainter);
        De.IsNull(_destroyMarkerPainter);
        De.IsNull(_copyAreaPainter);
        _selectedBatchBuilder.Verification();
        _selectedPainter.Verification();
        _designBatchBuilder.Verification();
        _demolishAreaPainter.Verification();
        _buildEffectPainter.Verification();
        _destroyMarkerPainter.Verification();
        _copyAreaPainter.Verification();
    }
    // 외부에 전달할 데이터 생성
    public void DataBuilder()
    {

    }
    // 스크립트 내부 변수 초기화
    public void Initialize()
    {
        for (int i = 0; i < _uiBuildButton.Length; ++i) {
            _uiBuildButton[i].Initialize();
        }
        _selectedBatchBuilder.Initialize();
        _designBatchBuilder.Initialize();
        _demolishAreaPainter.Initialize();
        _buildEffectPainter.Initialize();
        _destroyMarkerPainter.Initialize();
        _copyAreaPainter.Initialize();
    }
    // 마스터 매니저의 Update() 에서 호출할 메서드
    public void RunBeforeFrame()
    {
        
    }
    // 마스터 매니저의 LateUpdate() 에서 호출할 메서드
    public void RunAfterFrame()
    {
        _selectedBatchBuilder.RunAfterFrame();
        _selectedPainter.RunAfterFrame();
        _designBatchBuilder.RunAfterFrame();
        _demolishAreaPainter.RunAfterFrame();
        _buildEffectPainter.RunAfterFrame();
        _destroyMarkerPainter.RunAfterFrame();
        _copyAreaPainter.RunAfterFrame();
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Block_Logic\BlockLogicManager.cs 
// ======================================================== 
 
﻿using UnityEngine;
/// <summary>
/// 블록 로직 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 블록 로직 스크립트를 호출합니다.
/// </summary>
public class BlockLogicManager : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private BlockSODataBuilder _blockSODataBuilder;
    [SerializeField] private BlockPartUpdater _blockPartUpdater;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 인스펙터 유효성 검사
    public void Verification()
    {
        De.IsNull(_blockSODataBuilder);
        De.IsNull(_blockPartUpdater);
    }
    // 스크립트 내부 변수 초기화
    public void Initialize()
    {
        _blockPartUpdater.Initialize();
    }
    // 외부에 전달할 데이터 생성
    public void DataBuilder()
    {
        _blockSODataBuilder.DataBuilder();
    }
    // 마스터 매니저의 Update() 에서 호출할 메서드
    public void RunBeforeFrame()
    {
        _blockPartUpdater.RunBeforeFrame();
    }
    // 마스터 매니저의 LateUpdate() 에서 호출할 메서드
    public void RunAfterFrame()
    {

    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Block_Logic\BlockPartUpdater.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 블록 로직 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 매 프레임 모든 활성 블록의 부품 각도와 이펙트 타이머를 업데이트합니다.
///
/// partAngle_1 : Body — 지수 보간으로 플레이어를 바라봄 (가까울수록 감속)
/// partAngle_2 : Turret — 일정 속도로 플레이어를 향해 최단 경로 회전
/// partAngle_3 : Rotation — 일정 속도로 자전
/// effectTimer : Effect — 삼각파 타이머 (투명도 계산용)
/// </summary>
public class BlockPartUpdater : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Transform _playerTransform;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private PoolManagement<BlockSingle> _pool;
    private BlockMap _blockMap;
    private Dictionary<EBlock, SO_Block> _blockSO;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Verification()
    {
        De.IsNull(_playerTransform);
    }

    public void Initialize()
    {
        GameData game = GameData.ins;
        _pool = game.BlockPool;
        _blockMap = game.Blocks;
        _blockSO = game.BlockDatabase;
    }

    public void RunBeforeFrame()
    {
        float dt = Time.deltaTime;
        float playerX = _playerTransform.position.x;
        float playerY = _playerTransform.position.y;
        int capacity = _pool.Capacity;

        for (int adress = 0; adress < capacity; ++adress) {
            if (!_pool.IsExist(adress))
                continue;

            ref BlockSingle block = ref _pool.GetRef(adress);
            if (block.IsVoid())
                continue;

            if (!_blockSO.TryGetValue(block.id, out SO_Block so))
                continue;

            // 블록 렌더링 중심
            Vector2 renderPos = _blockMap.GetRenderPos(block.index, block.size, block.rotation);
            float dx = playerX - renderPos.x;
            float dy = playerY - renderPos.y;
            float targetAngle = Mathf.Atan2(dy, dx) * Mathf.Rad2Deg - 90f;

            // ── partAngle_1 : Body (지수 보간) ──
            float bodyDelta = Mathf.DeltaAngle(block.partAngle_1, targetAngle);
            block.partAngle_1 += bodyDelta * Mathf.Clamp01(so.BodyRotateSpeed * dt);

            // ── partAngle_2 : Turret (일정 속도, 최단 경로) ──
            float turretDelta = Mathf.DeltaAngle(block.partAngle_2, targetAngle);
            float maxStep = so.TurretRotateSpeed * dt;
            if (Mathf.Abs(turretDelta) <= maxStep)
                block.partAngle_2 = targetAngle;
            else
                block.partAngle_2 += Mathf.Sign(turretDelta) * maxStep;

            // ── partAngle_3 : Rotation (자전) ──
            block.partAngle_3 += so.RotationSpeed * dt;
            if (block.partAngle_3 > 360f) block.partAngle_3 -= 360f;
            else if (block.partAngle_3 < -360f) block.partAngle_3 += 360f;

            // ── effectTimer : Effect (삼각파 누적) ──
            float fullCycle = so.EffectCycleTime * 2f;
            block.effectTimer += dt;
            if (block.effectTimer >= fullCycle)
                block.effectTimer -= fullCycle;
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Block_Logic\BlockSODataBuilder.cs 
// ======================================================== 
 
using System.Collections.Generic;
using UnityEngine;
/// <summary>
/// 블록 로직 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// Block Scriptable Object를 사용할 수 있도록 딕셔너리화 합니다.
/// </summary>
public class BlockSODataBuilder : MonoBehaviour
{
    // Resources 폴더에 있는 SO_Block 자동으로 가져오기
    public void DataBuilder()
    {
        SO_Block[] loaded = Resources.LoadAll<SO_Block>("SOData/Block");
        // 스크립터블 오브젝트 파일이 없음
        int length = loaded.Length;
        if (De.IsTrue(length <= 0)) {
            De.Print("블록 스크립터블 오브젝트가 존재하지 않습니다.");
            return;
        }
        // 딕셔너리화
        var tempDic = new Dictionary<EBlock, SO_Block>(length);
        for (int i = 0; i < length; ++i) {
            EBlock key = loaded[i].ID;
            if (De.IsTrue(tempDic.ContainsKey(key)))
                continue;
            tempDic.Add(loaded[i].ID, loaded[i]);
        }
        GameData.ins.BlockDatabase = tempDic;
        De.Print("블록 데이터베이스에 데이터를 주입했습니다.");
    }
} 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Player_Logic\PlayerArchitect.cs 
// ======================================================== 
 
﻿using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// 플레이어의 건설 로직을 관리하고 키 이벤트를 구독합니다.
/// partial class로 Build / Demolish / Design / Selected 파일과 연결됩니다.
/// </summary>
public partial class PlayerArchitect : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Camera _camera;
    [SerializeField] private PlayerInput _input;
    [SerializeField] private Transform _playerTransform;

    [Header("사용자 정의 설정")]
    [SerializeField] private float _rotateInterval = 0.1f;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private float _nextRotateTime;
    private bool _dragPlacer;
    private bool _dragCopy;
    private SelectedBlock _stretchOriginal;

    // 캐싱
    private GameData _game;
    private int _width;
    private int _height;
    private BlockMap _blockMap;
    private PoolManagement<BlockSingle> _blockPool;
    private Dictionary<EBlock, SO_Block> _blockSO;
    private PlayerSingle _player;
    private List<SelectedBlock> _selecteds;
    private Dictionary<int, BuildOrder> _designs;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 외부 공개 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 인스펙터 필수 요소 검증
    /// </summary>
    public void Verification()
    {
        De.IsNull(_camera);
        De.IsNull(_input);
        De.IsNull(_playerTransform);
    }

    /// <summary>
    /// 캐싱 및 이벤트 구독
    /// </summary>
    public void Initialize()
    {
        _game = GameData.ins;
        _width = _game.TileMap.Width;
        _height = _game.TileMap.Height;
        _blockMap = _game.Blocks;
        _blockPool = _game.BlockPool;
        _blockSO = _game.BlockDatabase;
        _player = _game.Player;
        _selecteds = _player.selecteds;
        _designs = _player.designs;
        _stretchOriginal = default;
        _copyAdressSet = new HashSet<int>();

        InitializeDesign();
        SubscribeEvents();
    }

    /// <summary>
    /// 매 프레임 로직 갱신
    /// </summary>
    public void RunBeforeFrame()
    {
        UpdateBuild();
    }

    public void RunAfterFrame() { }
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private void SubscribeEvents()
    {
        _input.OnScrollUp += OnRotateCW;
        _input.OnScrollDown += OnRotateCCW;
        _input.OnInteractOnce += OnPlaceOnce;
        _input.OnInteractDrag += OnPlaceDrag;
        _input.OnInteractDragEnd += OnPlaceDragEnd;
        _input.OnCopyBlockOnce += OnCopyOnce;
        _input.OnCopyBlockDrag += OnCopyDrag;
        _input.OnCopyBlockDragEnd += OnCopyDragEnd;
        _input.OnDemolishNow += OnDemolishNow;
        _input.OnDemolishOnce += OnDemolishOnce;
        _input.OnDemolishDrag += OnDemolishDrag;
        _input.OnDemolishDragEnd += OnDemolishDragEnd;
        _input.OnBuildReset += OnBuildReset;
    }

    private void UnsubscribeEvents()
    {
        _input.OnScrollUp -= OnRotateCW;
        _input.OnScrollDown -= OnRotateCCW;
        _input.OnInteractOnce -= OnPlaceOnce;
        _input.OnInteractDrag -= OnPlaceDrag;
        _input.OnInteractDragEnd -= OnPlaceDragEnd;
        _input.OnCopyBlockOnce -= OnCopyOnce;
        _input.OnCopyBlockDrag -= OnCopyDrag;
        _input.OnCopyBlockDragEnd -= OnCopyDragEnd;
        _input.OnDemolishNow -= OnDemolishNow;
        _input.OnDemolishOnce -= OnDemolishOnce;
        _input.OnDemolishDrag -= OnDemolishDrag;
        _input.OnDemolishDragEnd -= OnDemolishDragEnd;
        _input.OnBuildReset -= OnBuildReset;
    }
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메시지 함수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private void OnDestroy()
    {
        UnsubscribeEvents();
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Player_Logic\PlayerArchitect_Build.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 디자인 블록을 자동 건설/철거합니다.
/// buildInterval마다 buildRange 내의 디자인 블록 1개를 처리합니다.
/// </summary>
public partial class PlayerArchitect
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private float _buildTimer;
    private float _lookAtBuildEndTime;
    private Vector2 _lastBuildPos;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 이벤트 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 건설/철거 시 외부에 알림 (center, sizeX, sizeY)
    // BuildEffectPainter, SoundAdmin 등이 구독
    public static event System.Action<Vector2, float, float> OnBuildEffect;
    public static event System.Action<Vector2, float, float> OnDestroyEffect;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 매 프레임 호출. 쿨타임 관리 및 건설/철거 시도.
    /// </summary>
    private void UpdateBuild()
    {
        if (_designs.Count <= 0) {
            _player.lookAtBuild = false;
            return;
        }

        // 바라보기 시간 만료
        if (_player.lookAtBuild && Time.time >= _lookAtBuildEndTime)
            _player.lookAtBuild = false;

        // Shift 가속
        float speed = Input.GetKey(KeyCode.LeftShift) ? _player.buildSpeedMultiplier : 1f;
        _buildTimer -= Time.deltaTime * speed;

        if (_buildTimer > 0f) {
            if (_player.lookAtBuild)
                ApplyLookAtBuild();
            return;
        }

        // 쿨타임 리셋 및 건설 시도
        _buildTimer = _player.buildInterval;

        if (TryProcessOneDesign()) {
            _player.lookAtBuild = true;
            _lookAtBuildEndTime = Time.time + _player.buildInterval;
        }
    }

    /// <summary>
    /// buildRange 직사각형 내에서 첫 번째 디자인 블록을 처리합니다.
    /// </summary>
    private bool TryProcessOneDesign()
    {
        Vector2 playerPos = (Vector2)_playerTransform.position;
        float half = _player.buildRange * 0.5f;

        int minX = Mathf.Max(0, Mathf.FloorToInt(playerPos.x - half));
        int maxX = Mathf.Min(_width - 1, Mathf.FloorToInt(playerPos.x + half));
        int minY = Mathf.Max(0, Mathf.FloorToInt(playerPos.y - half));
        int maxY = Mathf.Min(_height - 1, Mathf.FloorToInt(playerPos.y + half));

        for (int y = minY; y <= maxY; ++y) {
            for (int x = minX; x <= maxX; ++x) {
                int index = UGrid.GridToIndex(x, y, _width);
                int designCenter = _designOccupied[index];
                if (designCenter == -1)
                    continue;
                if (!_designs.TryGetValue(designCenter, out BuildOrder order))
                    continue;

                if (order.type == EOrderType.Build)
                    return TryExecuteBuild(designCenter, order);
                if (order.type == EOrderType.Destroy)
                    return TryExecuteDestroy(designCenter, order);
            }
        }
        return false;
    }

    /// <summary>
    /// Build 디자인 → 실제 블록 배치
    /// </summary>
    private bool TryExecuteBuild(int centerIndex, BuildOrder order)
    {
        if (!_blockSO.TryGetValue(order.id, out SO_Block so)) {
            RemoveDesign(centerIndex);
            return false;
        }

        float sizeX = so.Size.x;
        float sizeY = so.Size.y;

        if (!_blockMap.TryPlace(centerIndex, order.id, order.rotation)) {
            RemoveDesign(centerIndex);
            return false;
        }

        RemoveDesign(centerIndex);
        Vector2Int size = new Vector2Int((int)sizeX, (int)sizeY);
        _lastBuildPos = _blockMap.GetRenderPos(centerIndex, size, order.rotation);
        OnBuildEffect?.Invoke(_lastBuildPos, sizeX, sizeY);
        return true;
    }

    /// <summary>
    /// Destroy 디자인 → 실제 블록 철거
    /// </summary>
    private bool TryExecuteDestroy(int centerIndex, BuildOrder order)
    {
        if (!_blockMap.InMap(centerIndex) || _blockMap.IsVoid(centerIndex)) {
            RemoveDesign(centerIndex);
            return false;
        }

        int adress = _blockMap.GetAdress(centerIndex);
        ref readonly BlockSingle block = ref _blockPool.Read(adress);
        float sizeX = block.size.x;
        float sizeY = block.size.y;
        Vector2 renderPos = _blockMap.GetRenderPos(block.index, block.size, block.rotation);

        _blockMap.TryRemove(centerIndex);
        RemoveDesign(centerIndex);

        _lastBuildPos = renderPos;
        OnDestroyEffect?.Invoke(renderPos, sizeX, sizeY);
        return true;
    }

    /// <summary>
    /// 건설/철거 대상 방향으로 플레이어를 회전합니다.
    /// </summary>
    private void ApplyLookAtBuild()
    {
        Vector2 dir = _lastBuildPos - (Vector2)_playerTransform.position;
        if (dir.sqrMagnitude < 0.001f)
            return;
        float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
        Quaternion target = Quaternion.Euler(0f, 0f, angle - 90f);
        _playerTransform.rotation = Quaternion.Lerp(_playerTransform.rotation, target, 0.15f);
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Player_Logic\PlayerArchitect_Demolish.cs 
// ======================================================== 
 
﻿using UnityEngine;
using UnityEngine.EventSystems;

/// <summary>
/// 우클릭 철거 로직.
/// 디자인 블록(Build) → 즉시 삭제, 실제 블록 → Destroy 디자인 등록.
/// </summary>
public partial class PlayerArchitect
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 (철거 이벤트) 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 우클릭 누른 순간 — 선택 블록이 있으면 취소 처리
    /// </summary>
    private void OnDemolishNow(Vector2 pos)
    {
        if (EventSystem.current.IsPointerOverGameObject())
            return;
        if (_selecteds.Count <= 0)
            return;
        _dragCopy = false;
        _dragPlacer = false;
        _selecteds.Clear();
        _stretchOriginal = default;
    }

    /// <summary>
    /// 우클릭 단일 — 해당 셀 처리
    /// </summary>
    private void OnDemolishOnce(Vector2 pos)
    {
        _player.demolishActive = false;
        if (EventSystem.current.IsPointerOverGameObject())
            return;
        if (_selecteds.Count > 0)
            return;

        Vector2 grid = UGrid.WorldToGrid(pos);
        int gx = (int)grid.x;
        int gy = (int)grid.y;
        if (gx < 0 || _width <= gx || gy < 0 || _height <= gy)
            return;

        DemolishCell(UGrid.GridToIndex(gx, gy, _width));
    }

    /// <summary>
    /// 우클릭 드래그 중 — 영역 시각화 갱신
    /// </summary>
    private void OnDemolishDrag(Vector2 startPos, Vector2 endPos)
    {
        if (_selecteds.Count > 0)
            return;

        (int minX, int minY, int maxX, int maxY) = UGrid.GetForeachPos(startPos, endPos);
        _player.demolishMinX = minX;
        _player.demolishMinY = minY;
        _player.demolishMaxX = maxX;
        _player.demolishMaxY = maxY;
        _player.demolishActive = true;
    }

    /// <summary>
    /// 우클릭 드래그 끝 — 영역 내 모든 셀 철거
    /// </summary>
    private void OnDemolishDragEnd(Vector2 startPos, Vector2 endPos)
    {
        _player.demolishActive = false;
        if (_selecteds.Count > 0)
            return;

        (int minX, int minY, int maxX, int maxY) = UGrid.GetForeachPos(startPos, endPos);
        for (int y = minY; y <= maxY; ++y) {
            for (int x = minX; x <= maxX; ++x) {
                if (x < 0 || _width <= x || y < 0 || _height <= y)
                    continue;
                DemolishCell(UGrid.GridToIndex(x, y, _width));
            }
        }
    }

    /// <summary>
    /// 셀 단위 철거. Build 디자인 → 즉시 삭제, 실제 블록 → Destroy 등록.
    /// </summary>
    private void DemolishCell(int index)
    {
        // 디자인 블록 확인
        int occupiedBy = _designOccupied[index];
        if (occupiedBy != -1) {
            if (_designs.TryGetValue(occupiedBy, out BuildOrder existing)) {
                if (existing.type == EOrderType.Build)
                    RemoveDesign(occupiedBy);
                // Destroy 디자인은 이미 등록됨
                return;
            }
        }

        // 실제 블록 확인
        if (!_blockMap.InMap(index) || _blockMap.IsVoid(index))
            return;

        int adress = _blockMap.GetAdress(index);
        ref readonly BlockSingle block = ref _blockPool.Read(adress);
        int centerIndex = block.index;

        // 중복 등록 방지
        if (_designs.ContainsKey(centerIndex))
            return;

        // Destroy 디자인 등록
        _designs[centerIndex] = new BuildOrder(centerIndex, EOrderType.Destroy, block.id, block.rotation);

        // 점유맵 등록
        if (_blockSO.TryGetValue(block.id, out SO_Block so)) {
            Vector2Int size = new Vector2Int((int)so.Size.x, (int)so.Size.y);
            int cellCount = _blockMap.GetOccupiedCells(centerIndex, size, block.rotation, _placeCellBuffer);
            for (int c = 0; c < cellCount; ++c)
                _designOccupied[_placeCellBuffer[c]] = centerIndex;
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Player_Logic\PlayerArchitect_Design.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 선택한 블록을 디자인 블록(건설 예정)으로 전환하고, 점유맵을 관리합니다.
/// </summary>
public partial class PlayerArchitect
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 디자인 점유맵 (값 = 중심 인덱스, -1 = 비점유)
    private int[] _designOccupied;
    private int[] _placeCellBuffer;
    private int[] _removeCellBuffer;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 디자인 점유맵 및 셀 버퍼 초기화
    /// </summary>
    private void InitializeDesign()
    {
        int length = _width * _height;
        _designOccupied = new int[length];
        for (int i = 0; i < length; ++i)
            _designOccupied[i] = -1;
        _placeCellBuffer = new int[36];
        _removeCellBuffer = new int[36];
    }

    /// <summary>
    /// 현재 selecteds를 커서 위치 기준으로 디자인 블록에 배치합니다.
    /// </summary>
    private void TrySelectedToDesign()
    {
        int selCount = _selecteds.Count;
        if (selCount <= 0)
            return;

        Vector2 cursor = _player.CursorInGrid;
        float cx = cursor.x;
        float cy = cursor.y;
        TileMap tile = _game.TileMap;

        for (int i = 0; i < selCount; ++i) {
            SelectedBlock sel = _selecteds[i];
            if (sel.id == EBlock.None)
                continue;

            // 그리드 스냅
            int gx = Mathf.FloorToInt(cx + sel.offsetX);
            int gy = Mathf.FloorToInt(cy + sel.offsetY);
            if (gx < 0 || _width <= gx || gy < 0 || _height <= gy)
                continue;

            int centerIndex = UGrid.GridToIndex(gx, gy, _width);

            if (!_blockSO.TryGetValue(sel.id, out SO_Block so))
                continue;
            Vector2Int size = new Vector2Int((int)so.Size.x, (int)so.Size.y);

            // 점유할 셀 계산
            int cellCount = _blockMap.GetOccupiedCells(centerIndex, size, sel.rotation, _placeCellBuffer);
            if (cellCount <= 0)
                continue;

            // 실제 블록 또는 비지상 타일과 겹치면 스킵
            bool blocked = false;
            for (int c = 0; c < cellCount; ++c) {
                int cell = _placeCellBuffer[c];
                if (_blockMap.IsExist(cell) || !tile.IsGround(cell)) {
                    blocked = true;
                    break;
                }
            }
            if (blocked)
                continue;

            // 겹치는 기존 디자인 제거
            for (int c = 0; c < cellCount; ++c) {
                int occupiedBy = _designOccupied[_placeCellBuffer[c]];
                if (occupiedBy != -1)
                    RemoveDesign(occupiedBy);
            }

            // 새 디자인 등록
            _designs[centerIndex] = new BuildOrder(centerIndex, EOrderType.Build, sel.id, sel.rotation);
            for (int c = 0; c < cellCount; ++c)
                _designOccupied[_placeCellBuffer[c]] = centerIndex;
        }
    }

    /// <summary>
    /// 중심 인덱스로 디자인 블록 1개를 제거합니다.
    /// </summary>
    private void RemoveDesign(int centerIndex)
    {
        if (!_designs.TryGetValue(centerIndex, out BuildOrder order))
            return;

        // 점유맵 해제
        if (_blockSO.TryGetValue(order.id, out SO_Block so)) {
            Vector2Int size = new Vector2Int((int)so.Size.x, (int)so.Size.y);
            int cellCount = _blockMap.GetOccupiedCells(centerIndex, size, order.rotation, _removeCellBuffer);
            for (int c = 0; c < cellCount; ++c)
                _designOccupied[_removeCellBuffer[c]] = -1;
        }

        _designs.Remove(centerIndex);
    }

    /// <summary>
    /// 모든 디자인 블록을 제거합니다.
    /// </summary>
    public void ClearAllDesigns()
    {
        _designs.Clear();
        int length = _designOccupied.Length;
        for (int i = 0; i < length; ++i)
            _designOccupied[i] = -1;
    }

    /// <summary>
    /// Q키 — 선택 블록 + 디자인 블록 전체 초기화
    /// </summary>
    private void OnBuildReset()
    {
        _selecteds.Clear();
        _stretchOriginal = default;
        ClearAllDesigns();
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Player_Logic\PlayerArchitect_Selected.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

/// <summary>
/// 블록 선택 · 복사 · 회전 · 드래그 배치
/// </summary>
public partial class PlayerArchitect
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 복사 시 대형 블록 중복 방지용
    private HashSet<int> _copyAdressSet;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 (복사) 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 단일 셀의 블록을 selected로 복사합니다.
    /// </summary>
    private void TryCopySingle(int index, float offsetX, float offsetY)
    {
        if (!_blockMap.InMap(index) || _blockMap.IsVoid(index))
            return;
        int adress = _blockMap.GetAdress(index);
        ref readonly BlockSingle block = ref _blockPool.Read(adress);
        _selecteds.Add(new SelectedBlock(offsetX, offsetY, block.id, block.rotation));
    }

    /// <summary>
    /// 두 좌표 사이의 모든 블록을 selected로 복사합니다.
    /// </summary>
    private void TryCopyRange(Vector2 startPos, Vector2 endPos)
    {
        (int minX, int minY, int maxX, int maxY) = UGrid.GetForeachPos(startPos, endPos);
        float centerX = (minX + maxX) * 0.5f;
        float centerY = (minY + maxY) * 0.5f;

        _copyAdressSet.Clear();
        for (int y = minY; y <= maxY; ++y) {
            for (int x = minX; x <= maxX; ++x) {
                int index = UGrid.GridToIndex(x, y, _width);
                if (!_blockMap.InMap(index) || _blockMap.IsVoid(index))
                    continue;
                int adress = _blockMap.GetAdress(index);
                if (!_copyAdressSet.Add(adress))
                    continue;
                ref readonly BlockSingle block = ref _blockPool.Read(adress);
                _selecteds.Add(new SelectedBlock(centerX - x, centerY - y, block.id, block.rotation));
            }
        }
    }
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 (드래그 타일링) 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 선택된 블록 1개를 드래그 영역에 직사각형 형태로 타일링합니다.
    /// </summary>
    private void RenewalStretchSelected(Vector2 startPos, Vector2 endPos)
    {
        if (!_player.CursorMoved || _stretchOriginal.IsVoid())
            return;
        if (!_blockSO.TryGetValue(_stretchOriginal.id, out SO_Block so))
            return;

        int sizeX = Mathf.Max(1, (int)so.Size.x);
        int sizeY = Mathf.Max(1, (int)so.Size.y);

        // 회전 시 크기 스왑
        if (_stretchOriginal.rotation == ERotation.Right || _stretchOriginal.rotation == ERotation.Left) {
            int tmp = sizeX;
            sizeX = sizeY;
            sizeY = tmp;
        }

        (int minX, int minY, int maxX, int maxY) = UGrid.GetForeachPos(startPos, endPos);
        Vector2 startGrid = UGrid.WorldToGrid(startPos);

        _selecteds.Clear();
        for (int y = minY; y <= maxY; y += sizeY) {
            for (int x = minX; x <= maxX; x += sizeX) {
                if (x < 0 || _width <= x || y < 0 || _height <= y)
                    continue;
                _selecteds.Add(new SelectedBlock(
                    startGrid.x - x, startGrid.y - y,
                    _stretchOriginal.id, _stretchOriginal.rotation
                ));
            }
        }
    }
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 (회전) 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 선택된 블록들의 오프셋과 회전을 90도 회전합니다.
    /// </summary>
    private void TrySelectedRotate(bool clockwise)
    {
        int count = _selecteds.Count;
        if (count <= 0)
            return;
        if (Time.unscaledTime < _nextRotateTime)
            return;
        _nextRotateTime = Time.unscaledTime + _rotateInterval;

        float sin = clockwise ? 1f : -1f;
        float cos = 0f;

        for (int i = 0; i < count; ++i) {
            SelectedBlock sel = _selecteds[i];
            float ox = sel.offsetX * cos - sel.offsetY * sin;
            float oy = sel.offsetX * sin + sel.offsetY * cos;
            sel.offsetX = ox;
            sel.offsetY = oy;
            sel.rotation = clockwise ? UGrid.RotateCW(sel.rotation) : UGrid.RotateCCW(sel.rotation);
            _selecteds[i] = sel;
        }

        // 원본도 함께 회전 (드래그 타일링 중)
        if (!_stretchOriginal.IsVoid()) {
            _stretchOriginal.rotation = clockwise
                ? UGrid.RotateCW(_stretchOriginal.rotation)
                : UGrid.RotateCCW(_stretchOriginal.rotation);
        }
    }
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 (이벤트 핸들러) 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private void OnRotateCW() => TrySelectedRotate(true);
    private void OnRotateCCW() => TrySelectedRotate(false);

    // ── 단일 클릭 배치 ──
    private void OnPlaceOnce(Vector2 pos)
    {
        if (EventSystem.current.IsPointerOverGameObject())
            return;
        if (_selecteds.Count <= 0)
            return;
        TrySelectedToDesign();
    }

    // ── 드래그 배치 ──
    private void OnPlaceDrag(Vector2 startPos, Vector2 endPos)
    {
        if (EventSystem.current.IsPointerOverGameObject())
            return;
        if (_dragCopy)
            return;
        if (!_dragPlacer) {
            _dragPlacer = true;
            if (_selecteds.Count > 0)
                _stretchOriginal = _selecteds[0];
        }
        RenewalStretchSelected(startPos, endPos);
    }

    private void OnPlaceDragEnd(Vector2 startPos, Vector2 endPos)
    {
        if (_dragCopy)
            return;
        _dragPlacer = false;
        TrySelectedToDesign();
        _selecteds.Clear();
        _stretchOriginal = default;
    }

    // ── 단일 복사 ──
    private void OnCopyOnce(Vector2 clickPos)
    {
        _player.copyActive = false;
        if (EventSystem.current.IsPointerOverGameObject())
            return;
        if (_dragCopy || _dragPlacer)
            return;
        _selecteds.Clear();
        int index = UGrid.WorldToIndex(clickPos, _width);
        TryCopySingle(index, 0f, 0f);
    }

    // ── 드래그 복사 ──
    private void OnCopyDrag(Vector2 startPos, Vector2 endPos)
    {
        if (_dragPlacer)
            return;
        _dragCopy = true;
        // 영역 시각화만 갱신
        (int minX, int minY, int maxX, int maxY) = UGrid.GetForeachPos(startPos, endPos);
        _player.copyMinX = minX;
        _player.copyMinY = minY;
        _player.copyMaxX = maxX;
        _player.copyMaxY = maxY;
        _player.copyActive = true;
    }

    private void OnCopyDragEnd(Vector2 startPos, Vector2 endPos)
    {
        _player.copyActive = false;
        if (_dragPlacer)
            return;
        _dragCopy = false;
        _selecteds.Clear();
        TryCopyRange(startPos, endPos);
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Player_Logic\PlayerDataBuilder.cs 
// ======================================================== 
 
﻿using UnityEngine;
/// <summary>
/// 플레이어 로직 매니저 오브젝트에 부착하는 스크립트입니다.
/// 플레이어 데이터 생성과 업데이트를 담당합니다.
/// </summary>
public class PlayerDataBuilder : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("사용자 정의 설정")]
    [SerializeField] private float _buildRange = 20f;
    [SerializeField] private float _buildInterval = 0.06f;
    [Tooltip("Shift 키를 누른 상태에서의 건설 속도 배율")]
    [SerializeField] private float _buildSpeedMultiplier = 2f;
    #endregion

    private PlayerSingle _player;
    private Camera _camera;

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void Initialize()
    {
        _player = GameData.ins.Player;
        _camera = Camera.main;
    }

    public void DataBuilder()
    {
        GameData game = GameData.ins;
        game.Player = new PlayerSingle(
            game.TileMap.Width, game.TileMap.Height,
            _buildRange, _buildInterval, _buildSpeedMultiplier
        );
    }

    public void RunBeforeFrame()
    {
        _player.UpdateCursor(_camera);
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Player_Logic\PlayerInput.cs 
// ======================================================== 
 
﻿using System;
using UnityEngine;
/// <summary>
/// 플레이어 로직 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 유저의 키 입력을 인식해서 이벤트를 뿌립니다.
/// GetAxis는 이곳에서 관리하지 않고 각 스크립트에서 알아서 합니다.
/// </summary>
public class PlayerInput : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Camera _camera;

    [Header("사용자 정의 설정")]
    [SerializeField] private KeyCode _interact = KeyCode.Mouse0;
    [SerializeField] private KeyCode _demolish = KeyCode.Mouse1;
    [SerializeField] private KeyCode _gamePause = KeyCode.Space;
    [SerializeField] private KeyCode _buildReset = KeyCode.Q;
    [SerializeField] private KeyCode _holdBuild = KeyCode.E;
    [SerializeField] private KeyCode _copyBlock = KeyCode.F;
    [SerializeField] private KeyCode _symmetryHori = KeyCode.Z;
    [SerializeField] private KeyCode _symmetryVert = KeyCode.X;
    [SerializeField] private float _dragThreshold = 10f;
    [SerializeField] private float _scrollInterval = 0.1f;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public event Action<Vector2> OnMovementPress;
    public event Action<Vector2> OnInteractNow;
    public event Action<Vector2> OnInteractOnce;
    public event Action<Vector2, Vector2> OnInteractDrag;
    public event Action<Vector2, Vector2> OnInteractDragEnd;
    public event Action<Vector2> OnDemolishNow;
    public event Action<Vector2> OnDemolishOnce;
    public event Action<Vector2, Vector2> OnDemolishDrag;
    public event Action<Vector2, Vector2> OnDemolishDragEnd;
    public event Action OnGamePause;
    public event Action OnBuildReset;
    public event Action OnHoldBuild;
    public event Action<Vector2> OnCopyBlockOnce;
    public event Action<Vector2, Vector2> OnCopyBlockDrag;
    public event Action<Vector2, Vector2> OnCopyBlockDragEnd;
    public event Action OnSymmetryHori;
    public event Action OnSymmetryVert;
    public event Action OnScrollUp;
    public event Action OnScrollDown;
    private bool _interactDrag;
    private bool _demolishDrag;
    private bool _copyBlockDrag;
    private float _nextScroll;
    private Vector2 _dragStartInteractPoint = Vector2.zero;
    private Vector2 _dragStartDemolishPoint = Vector2.zero;
    private Vector2 _dragStartCopyBlockPoint = Vector2.zero;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 마스터 매니저의 Update() 에서 호출할 메서드
    public void RunBeforeFrame()
    {
        Vector2 pos = Tool.GetMousePos(_camera);
        // 드래그 시작 판정
        if (_dragStartInteractPoint != Vector2.zero) {
            if (!UMath.IsWithinDistance(_dragStartInteractPoint, pos, _dragThreshold) && !_interactDrag) {
                _interactDrag = true;
            }
        }
        if (_dragStartDemolishPoint != Vector2.zero) {
            if (!UMath.IsWithinDistance(_dragStartDemolishPoint, pos, _dragThreshold) && !_demolishDrag) {
                _demolishDrag = true;
            }
        }
        if (_dragStartCopyBlockPoint != Vector2.zero) {
            if (!UMath.IsWithinDistance(_dragStartCopyBlockPoint, pos, _dragThreshold) && !_copyBlockDrag) {
                _copyBlockDrag = true;
            }
        }
        // 이동 키
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");
        if (h != 0 || v != 0)
            OnMovementPress?.Invoke(new Vector2(h, v));
        // 상호작용 키
        if (Input.GetKeyDown(_interact)) {
            OnInteractNow?.Invoke(pos);
            _dragStartInteractPoint = pos;
        }
        if (Input.GetKey(_interact) && _interactDrag) {
            OnInteractDrag?.Invoke(_dragStartInteractPoint, pos);
        }
        if (Input.GetKeyUp(_interact)) {
            if (_interactDrag) {
                OnInteractDragEnd?.Invoke(_dragStartInteractPoint, pos);
                _interactDrag = false;
            } else {
                OnInteractOnce?.Invoke(pos);
            }
            _dragStartInteractPoint = Vector2.zero;
        }
        // 블럭 철거 키
        if (Input.GetKeyDown(_demolish)) {
            OnDemolishNow?.Invoke(pos);
            _dragStartDemolishPoint = pos;
        }
        if (Input.GetKey(_demolish) && _demolishDrag) {
            OnDemolishDrag?.Invoke(_dragStartDemolishPoint, pos);
        }
        if (Input.GetKeyUp(_demolish)) {
            if (_demolishDrag) {
                OnDemolishDragEnd?.Invoke(_dragStartDemolishPoint, pos);
                _demolishDrag = false;
            } else {
                OnDemolishOnce?.Invoke(pos);
            }
            _dragStartDemolishPoint = Vector2.zero;
        }
        // 게임 일시정지
        if (Input.GetKeyDown(_gamePause)) {
            OnGamePause?.Invoke();
        }
        // 디자인 블록 리셋
        if (Input.GetKeyDown(_buildReset)) {
            OnBuildReset?.Invoke();
        }
        // 건설 일시중지
        if (Input.GetKeyDown(_holdBuild)) {
            OnHoldBuild?.Invoke();
        }
        // 블록을 디자인 블록으로 복사
        if (Input.GetKeyDown(_copyBlock)) {
            _dragStartCopyBlockPoint = pos;
        }
        if (Input.GetKey(_copyBlock) && _copyBlockDrag) {
            OnCopyBlockDrag?.Invoke(_dragStartCopyBlockPoint, pos);
        }
        if (Input.GetKeyUp(_copyBlock)) {
            if (_copyBlockDrag) {
                OnCopyBlockDragEnd?.Invoke(_dragStartCopyBlockPoint, pos);
                _copyBlockDrag = false;
            } else {
                OnCopyBlockOnce?.Invoke(pos);
            }
            _dragStartCopyBlockPoint = Vector2.zero;
        }
        // 디자인 블록 대칭 이동
        if (Input.GetKeyDown(_symmetryHori)) {
            OnSymmetryHori?.Invoke();
        }
        if (Input.GetKeyDown(_symmetryVert)) {
            OnSymmetryVert?.Invoke();
        }
        // 마우스 스크롤 인식
        if (_nextScroll < Time.unscaledTime) {
            float scroll = Input.GetAxisRaw("Mouse ScrollWheel");
            if (0 < scroll) { // 오른쪽 회전
                _nextScroll = Time.unscaledTime + _scrollInterval;
                OnScrollUp?.Invoke();
            } else if (scroll < 0) { // 왼쪽 회전
                _nextScroll = Time.unscaledTime + _scrollInterval;
                OnScrollDown?.Invoke();
            }
        }
        // 게임 종료
        if (Input.GetKeyDown(KeyCode.Escape)) {
            Application.Quit();
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Player_Logic\PlayerLogicManager.cs 
// ======================================================== 
 
﻿using UnityEngine;
/// <summary>
/// 플레이어 로직 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 플레이어 로직 스크립트를 호출합니다.
/// </summary>
public class PlayerLogicManager : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private PlayerDataBuilder _playerDataBuilder;
    [SerializeField] private PlayerInput _playerInput;
    [SerializeField] private PlayerMover _playerMover;
    [SerializeField] private PlayerArchitect _playerArchitect;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 인스펙터 유효성 검사
    public void Verification()
    {
        De.IsNull(_playerDataBuilder);
        De.IsNull(_playerInput);
        De.IsNull(_playerMover);
        De.IsNull(_playerArchitect);
        _playerMover.Verification();
    }
    // 스크립트 내부 변수 초기화
    public void Initialize()
    {
        _playerDataBuilder.Initialize();
        _playerArchitect.Initialize();
        _playerMover.Initialize();
    }
    // 외부에 전달할 데이터 생성
    public void DataBuilder()
    {
        _playerDataBuilder.DataBuilder();
        //_playerArchitect.DataBuilder();
    }
    // 마스터 매니저의 Update() 에서 호출할 메서드
    public void RunBeforeFrame()
    {
        _playerDataBuilder.RunBeforeFrame();
        _playerInput.RunBeforeFrame();
        _playerArchitect.RunBeforeFrame();
    }
    // 마스터 매니저의 LateUpdate() 에서 호출할 메서드
    public void RunAfterFrame()
    {

    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Player_Logic\PlayerMover.cs 
// ======================================================== 
 
﻿using UnityEngine;

/// <summary>
/// 플레이어 오브젝트에 부착하는 스크립트입니다.
/// 키를 입력받아 8방향으로 이동합니다.
/// </summary>
public class PlayerMover : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private Transform _player;
    [SerializeField] private PlayerInput _input;

    [Header("사용자 정의 설정")]
    [SerializeField] private float _moveSpeed = 10;
    [SerializeField] private float _rotationSpeed = 10;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private float _minX, _maxX;
    private float _minY, _maxY;
    private PlayerSingle _playerData;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private void SetRotation(Vector2 axis)
    {
        // 건설/철거 중에는 해당 방향을 바라봐야 하므로 이동 방향 회전 스킵
        if (_playerData.lookAtBuild)
            return;
        float desiredAngle = Mathf.Atan2(axis.y, axis.x) * Mathf.Rad2Deg;
        Quaternion desiredQuaternion = Quaternion.Euler(0f, 0f, desiredAngle - 90f);
        _player.rotation = Quaternion.Lerp(_player.rotation, desiredQuaternion, 0.1f);
    }
    // 플레이어가 이동을 시도합니다.
    private void TryMove(Vector2 axis)
    {
        // 이동량 계산
        axis = Vector2.ClampMagnitude(axis, 1f);
        Vector2 movement = axis * _moveSpeed * Time.deltaTime;
        if (movement == Vector2.zero)
            return;
        // 이동 실행
        float prevX = _player.position.x;
        float prevY = _player.position.y;
        float x = prevX + movement.x;
        x = Mathf.Clamp(x, _minX, _maxX);
        float y = prevY + movement.y;
        y = Mathf.Clamp(y, _minY, _maxY);
        _player.position = new Vector3(x, y, -60f);
    }
    public void Verification()
    {
        De.IsNull(_player);
        De.IsNull(_input);
    }
    public void Initialize()
    {
        // 캐싱
        _playerData = GameData.ins.Player;
        var map = GameData.ins.TileMap;
        De.IsTrue(map.IsInvalid(), LogType.Assert, "타일 맵이 생성되지 않은 채 PlayerMover에 도착했습니다.");
        float outlineWall = (float)map.OutlineWall;
        _minX = outlineWall;
        _maxX = (float)map.Width - outlineWall;
        _minY = outlineWall;
        _maxY = (float)map.Height - outlineWall;
        // 이벤트
        _input.OnMovementPress += TryMove;
        _input.OnMovementPress += SetRotation;
    }
    #endregion

    private void OnDestroy()
    {
        _input.OnMovementPress -= TryMove;
        _input.OnMovementPress -= SetRotation;
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Tile_Logic\TileLogicManager.cs 
// ======================================================== 
 
﻿using UnityEngine;
/// <summary>
/// 타일 로직 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// 타일 로직 스크립트를 호출합니다.
/// </summary>
public class TileLogicManager : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private TileSODataBuilder _tileSODataBuilder;
    [SerializeField] private TileMapBuilder _tileMapBuilder;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    // 인스펙터 유효성 검사
    public void Verification()
    {
        De.IsNull(_tileSODataBuilder);
        De.IsNull(_tileMapBuilder);
        _tileMapBuilder.Verification();
    }
    // 스크립트 내부 변수 초기화
    public void Initialize()
    {

    }
    // 외부에 전달할 데이터 생성
    public void DataBuilder()
    {
        _tileSODataBuilder.DataBuilder();
        _tileMapBuilder.DataBuilder();
    }
    // 마스터 매니저의 Update() 에서 호출할 메서드
    public void RunBeforeFrame()
    {

    }
    // 마스터 매니저의 LateUpdate() 에서 호출할 메서드
    public void RunAfterFrame()
    {

    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Tile_Logic\TileMapBuilder.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using UnityEngine;

public class TileMapBuilder : MonoBehaviour
{
    [System.Serializable]
    public class OreConfig
    {
        [Tooltip("희귀한 광석이 앞 번호를 차지해야 한다.")]
        public EItem ore = EItem.None;
        [Tooltip("값이 클수록 광석 덩어리가 작다.")]
        [Range(0, 1)] public float scale;
        [Tooltip("값이 클수록 광석이 희귀하다.")]
        [Range(0, 1)] public float threshold;
    }
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private List<ETile> _groundTileID;
    [SerializeField] private List<ETile> _wallTileID;

    [Header("지형 생성 설정")]
    [SerializeField, Range(10, 1000)] private short _mapWidth = 100;
    [SerializeField, Range(10, 1000)] private short _mapHeight = 100;
    [SerializeField, Range(0, 100)] private int _noisePercent = 60;
    [SerializeField, Range(0, 10)] private int _smoothCount = 5;
    [SerializeField, Range(0, 10)] private int _outlineWall = 5;

    [Header("광석 생성 설정")]
    [SerializeField] private OreConfig[] _oreConfig;

    [Header("시드")]
    [SerializeField] private bool _isRandomSeed = true;
    [SerializeField] private int _seed;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    const int WALL_AROUND_RANGE = 1;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 맵을 생성하고 세포 자동자 알고리즘으로 지형과 타일을 결정합니다.
    /// 사용하는 타일은 TileBuilder의 인스펙터에서 등록해야 합니다.
    /// </summary>
    public void DataBuilder()
    {
        // 시드 결정
        if (_isRandomSeed) {
            _seed = UnityEngine.Random.Range(int.MinValue, int.MaxValue);
            UnityEngine.Random.InitState(_seed);
            De.Print($"맵 생성을 위한 시드를 생성했습니다. ({_seed})");
        }
        System.Random rand = new System.Random(_seed);
        // 맵 생성
        TileMap tempMap = new TileMap(_mapWidth, _mapHeight, _outlineWall);
        // 지형 결정
        SetRandomMap(ref tempMap, rand);
        for (int i = 0; i < _smoothCount; ++i) {
            SmoothMap(ref tempMap);
        }
        // 타일 랜덤 배치
        SetRandomTile(ref tempMap, rand);
        De.Print($"맵 생성을 완료했습니다. ({_mapWidth} * {_mapHeight})");
        // 광석 랜덤 적용
        SetRandomOre(ref tempMap);
        // 결과물 적용
        GameData.ins.TileMap = tempMap;
    }

    // 맵에 지상과 벽을 무작위로 결정합니다.
    private void SetRandomMap(ref TileMap map, System.Random rand)
    {
        TileSingle wall = new TileSingle(ETile.None, ETileType.Wall, EItem.None);
        TileSingle ground = new TileSingle(ETile.None, ETileType.Ground, EItem.None);
        for (short y = 0; y < _mapHeight; ++y) {
            for (short x = 0; x < _mapWidth; ++x) {
                int index = y * _mapWidth + x;
                // 외곽 벽 생성
                if (x < _outlineWall
                    || _mapWidth - _outlineWall < x
                    || y < _outlineWall
                    || _mapHeight - _outlineWall < y
                ) {
                    map.SetTile(index, wall);
                }
                // 랜덤 지형 생성
                else {
                    if (rand.Next(0, 100) < _noisePercent)
                        map.SetTile(index, ground);
                    else
                        map.SetTile(index, wall);
                }
            }
        }
    }

    // 자연스러운 지형이 되도록 개선합니다.
    private void SmoothMap(ref TileMap map)
    {
        TileSingle wall = new TileSingle(ETile.None, ETileType.Wall, EItem.None);
        TileSingle ground = new TileSingle(ETile.None, ETileType.Ground, EItem.None);
        for (short y = 0; y < _mapHeight; ++y) {
            for (short x = 0; x < _mapWidth; ++x) {
                // 주변에 벽이 5개 이상일 경우 Wall, 그렇지 않을 경우 Ground
                int aroundWall = GetAroundWall(ref map, x, y);
                int index = y * _mapWidth + x;
                if (5 <= aroundWall)
                    map.SetTile(index, wall);
                else
                    map.SetTile(index, ground);
            }
        }
    }

    // 주변에 있는 벽 개수를 셉니다.
    private int GetAroundWall(ref TileMap map, short centerX, short centerY)
    {
        int count = 0;
        // 주변 한 칸 순회 (3*3)
        for (int y = centerY - WALL_AROUND_RANGE; y <= centerY + WALL_AROUND_RANGE; ++y) {
            for (int x = centerX - WALL_AROUND_RANGE; x <= centerX + WALL_AROUND_RANGE; ++x) {
                // 맵을 벗어남
                if (x < 0) continue;
                if (_mapWidth <= x) continue;
                if (y < 0) continue;
                if (_mapHeight <= y) continue;
                // 벽 발견
                int index = y * _mapWidth + x;
                if (map.IsWall(index))
                    count++;
            }
        }
        return count;
    }

    // 지형에 맞춰 타일을 랜덤으로 배치합니다.
    private void SetRandomTile(ref TileMap map, System.Random rand)
    {
        for (short y = 0; y < _mapHeight; ++y) {
            for (short x = 0; x < _mapWidth; ++x) {
                int index = y * _mapWidth + x;
                // Random Wall
                if (map.IsWall(index)) {
                    int num = rand.Next(0, _wallTileID.Count);
                    map.SetID(index, _wallTileID[num]);
                }
                // Random Ground
                else {
                    int num = rand.Next(0, _groundTileID.Count);
                    map.SetID(index, _groundTileID[num]);
                }
            }
        }
    }

    // 바닥 타일에 광석을 펄린 노이즈로 자연스럽게 밀집시켜 생성합니다.
    private void SetRandomOre(ref TileMap map)
    {
        int length = _oreConfig.Length;
        // 광석마다 서로 다른 랜덤 오프셋
        Vector2[] offset = new Vector2[length];
        for (int i = 0; i < length; ++i) {
            offset[i].x = Random.Range(0f, 10000f);
            offset[i].y = Random.Range(0f, 10000f);
        }
        // 모든 타일 순회
        for (int y = 0; y < _mapHeight; ++y) {
            for (int x = 0; x < _mapWidth; ++x) {
                int index = UGrid.GridToIndex(x, y, _mapWidth);
                
                // 바닥 타일이어야 함
                if (!map.IsGround(index))
                    continue;
                // 가장 높은 노이즈를 가진 광석
                for (int i = 0; i < length; ++i) {
                    float scale = _oreConfig[i].scale;
                    float noiseX = x * scale + offset[i].x;
                    float noiseY = y * scale + offset[i].y;
                    float noise = Mathf.PerlinNoise(noiseX, noiseY);
                    // 광석이 임계값을 넘는가?
                    if (noise <_oreConfig[i].threshold)
                        continue;
                    // 광석 적용 완료
                    map.SetOre(index, _oreConfig[i].ore);
                    break;
                }
            }
        }
    }

    public void Verification()
    {
        UArray.IsInitedList(_groundTileID);
        UArray.IsInitedList(_wallTileID);
        UArray.IsInitedArray(_oreConfig);
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Logic\Tile_Logic\TileSODataBuilder.cs 
// ======================================================== 
 
using System.Collections.Generic;
using UnityEngine;
/// <summary>
/// 타일 로직 매니저 오브젝트에 부착하는 C# 스크립트입니다.
/// Tile Scriptable Object를 사용할 수 있도록 딕셔너리화 합니다.
/// </summary>
public class TileSODataBuilder : MonoBehaviour
{
    // Resources 폴더에 있는 SO_Tile 자동으로 가져오기
    public void DataBuilder()
    {
        SO_Tile[] loaded = Resources.LoadAll<SO_Tile>("SOData/Tile");
        // 스크립터블 오브젝트 파일이 없음
        int length = loaded.Length;
        if (De.IsTrue(length <= 0)) {
            De.Print("타일 스크립터블 오브젝트가 존재하지 않습니다.");
            return;
        }
        // 딕셔너리화
        var tempDic = new Dictionary<ETile, SO_Tile>(length);
        for (int i = 0; i < length; ++i) {
            ETile key = loaded[i].ID;
            if (De.IsTrue(tempDic.ContainsKey(key)))
                continue;
            tempDic.Add(loaded[i].ID, loaded[i]);
        }
        GameData.ins.TileDatabase = tempDic;
        De.Print("타일 데이터베이스에 데이터를 주입했습니다.");
    }
} 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Scene\BGMPlayer.cs 
// ======================================================== 
 
﻿using System;
using UnityEngine;
using UnityEngine.SceneManagement;

/// <summary>
/// 매니저 씬 오브젝트에 부착하는 C# 스크립트입니다.
/// 현재 활성 씬을 인식하여 해당 씬에 등록된 배경음 중 하나를 랜덤 재생합니다.
/// 씬 전환 시 자동으로 다음 씬의 배경음으로 전환합니다.
/// </summary>
public class BGMPlayer : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Serializable]
    public class SceneBGM
    {
        public string sceneName;
        public AudioClip[] clips;
    }

    [Header("필수 요소 등록")]
    [SerializeField] private SceneBGM[] _sceneBGMs;

    [Header("사용자 정의 설정")]
    [SerializeField, Range(0f, 1f)] private float _volume = 0.5f;
    [SerializeField] private float _fadeSpeed = 1f;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private AudioSource _source;
    private string _currentScene;
    private float _targetVolume;
    private bool _fading;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private void Awake()
    {
        // AudioSource 자동 생성
        _source = gameObject.AddComponent<AudioSource>();
        _source.loop = true;
        _source.playOnAwake = false;
        _source.volume = 0f;
        _currentScene = string.Empty;

        // 씬 전환 이벤트 구독
        SceneManager.activeSceneChanged += OnSceneChanged;
    }

    private void OnDestroy()
    {
        SceneManager.activeSceneChanged -= OnSceneChanged;
    }

    private void Start()
    {
        // 초기 씬 확인
        string active = SceneManager.GetActiveScene().name;
        TryPlayForScene(active);
    }

    private void Update()
    {
        if (!_fading)
            return;

        _source.volume = Mathf.MoveTowards(_source.volume, _targetVolume, _fadeSpeed * Time.unscaledDeltaTime);
        if (Mathf.Approximately(_source.volume, _targetVolume))
            _fading = false;
    }

    private void OnSceneChanged(Scene oldScene, Scene newScene)
    {
        TryPlayForScene(newScene.name);
    }

    private void TryPlayForScene(string sceneName)
    {
        if (sceneName == _currentScene)
            return;
        _currentScene = sceneName;

        // 해당 씬의 BGM 목록 검색
        AudioClip[] clips = null;
        for (int i = 0; i < _sceneBGMs.Length; ++i) {
            if (_sceneBGMs[i].sceneName == sceneName) {
                clips = _sceneBGMs[i].clips;
                break;
            }
        }

        // 클립이 없으면 페이드 아웃
        if (clips == null || clips.Length <= 0) {
            FadeOut();
            return;
        }

        // 랜덤 선택
        AudioClip chosen = clips[UnityEngine.Random.Range(0, clips.Length)];
        if (chosen == null) {
            FadeOut();
            return;
        }

        // 재생
        _source.clip = chosen;
        _source.Play();
        FadeIn();
    }

    private void FadeIn()
    {
        _targetVolume = _volume;
        _fading = true;
    }

    private void FadeOut()
    {
        _targetVolume = 0f;
        _fading = true;
    }

    /// <summary>
    /// 외부에서 볼륨을 변경할 때 사용합니다.
    /// </summary>
    public void SetVolume(float volume)
    {
        _volume = Mathf.Clamp01(volume);
        if (_source.isPlaying) {
            _targetVolume = _volume;
            _fading = true;
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Scene\SceneCatalog.cs 
// ======================================================== 
 
using System;
using System.Collections.Generic;
using UnityEngine;

public class SceneCatalog : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Serializable]
    public class SceneEntry
    {
        public ESceneID id;
        public string name;
    }
    [Header("씬 등록")]
    [SerializeField] private List<SceneEntry> _scenes = new List<SceneEntry>();

    [Header("옵션")]
    [SerializeField] private bool _buildOnAwake = true;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public enum ESceneID
    {
        Manager,
        Title,
        Planet,
        GamePlay,
        GameEnd,
        Count
    }
    private readonly Dictionary<ESceneID, string> _idToName = new Dictionary<ESceneID, string>((int)ESceneID.Count);
    private readonly Dictionary<string, ESceneID> _nameToID = new Dictionary<string, ESceneID>((int)ESceneID.Count);
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 씬 카탈로그를 다시 빌드합니다.
    /// </summary>
    [ContextMenu("카탈로그를 다시 빌드합니다.")]
    public void BuildMaps()
    {
        _idToName.Clear();
        _nameToID.Clear();
        De.Print($"씬 카탈로그를 청소했습니다.");
        for (int i = 0; i < _scenes.Count; ++i) {
            SceneEntry e = _scenes[i];
            // 비어있거나 중복 검사
            if(e == null)
                continue;
            if (De.IsTrue(string.IsNullOrEmpty(e.name)))
                continue;
            if (De.IsTrue(_idToName.ContainsKey(e.id)))
                continue;
            if (De.IsTrue(_nameToID.ContainsKey(e.name)))
                continue;
            // 등록
            _idToName.Add(e.id, e.name);
            _nameToID.Add(e.name, e.id);
            De.Print($"씬({e.id}, {e.name})을 카탈로그에 등록했습니다.");
        }
    }

    /// <summary>
    /// 해당 ID를 가진 씬이 존재할 경우 이름을 반환합니다.
    /// </summary>
    /// <param name="id"></param>
    /// <param name="name"></param>
    /// <returns></returns>
    public bool TryGetSceneName(ESceneID id, out string name)
    {
        return _idToName.TryGetValue(id, out name);
    }

    /// <summary>
    /// 해당 ID를 가진 씬이 존재할 경우 이름을 반환합니다.
    /// </summary>
    /// <param name="id"></param>
    /// <returns></returns>
    public string GetSceneName(ESceneID id)
    {
        if(_idToName.TryGetValue(id, out string name)) {
            return name;
        }
        return string.Empty;
    }

    /// <summary>
    /// 해당 이름을 가진 씬이 존재할 경우 ID를 반환합니다.
    /// </summary>
    /// <param name="name"></param>
    /// <param name="id"></param>
    /// <returns></returns>
    public bool TryGetSceneID(string name, out ESceneID id)
    {
        return _nameToID.TryGetValue(name, out id);
    }
    
    /// <summary>
    /// 원본 씬 리스트를 반환합니다.
    /// </summary>
    /// <returns></returns>
    public List<SceneEntry> GetEntries()
    {
        return _scenes;
    }

    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메시지 함수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private void Awake()
    {
        if (_buildOnAwake) {
            BuildMaps();
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Scene\SceneEffect.cs 
// ======================================================== 
 
using UnityEngine;
using System.Collections;

public class SceneEffect : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("페이드 설정")]
    [SerializeField] private CanvasGroup _fadeGroup;
    [SerializeField] private float _defaultFadeDuration = 0.25f;
    [SerializeField] private bool _useUnscaledTime = true;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private Coroutine _fadeRoutine;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    /// <summary>
    /// 씬 전환 설정을 초기화합니다.
    /// </summary>
    public void Initialize()
    {
        if (De.IsNull(_fadeGroup))
            return;
        _fadeGroup.alpha = 0f;
        _fadeGroup.blocksRaycasts = false;
        _fadeGroup.interactable = false;
        De.Print("씬 이펙트를 초기화했습니다.");
    }
    /// <summary>
    /// 지정한 투명 값으로 점차 페이드합니다.
    /// </summary>
    /// <param name="targetAlpha"></param>
    /// <param name="duration"></param>
    /// <param name="blockRayCastsWhileFading"></param>
    /// <returns></returns>
    public IEnumerator CFadeTo(float targetAlpha, float duration = -1f, bool blockRayCastsWhileFading = true)
    {
        if (De.IsNull(_fadeGroup))
            yield break;
        // 기본값 설정
        if (duration < 0f)
            duration = _defaultFadeDuration;
        // 기존 페이드 기능 종료
        if(_fadeRoutine != null) {
            StopCoroutine(_fadeRoutine);
            _fadeRoutine = null;
        }
        // 새로운 페이드 기능 시작
        _fadeRoutine = StartCoroutine(CFadeInternal(targetAlpha, duration, blockRayCastsWhileFading));
        yield return _fadeRoutine;
        _fadeRoutine = null;
    }
    /// <summary>
    /// Alpha 값을 보간합니다.
    /// </summary>
    /// <param name="targetAlpha"></param>
    /// <param name="duration"></param>
    /// <param name="blockRayCastsWhileFading"></param>
    /// <returns></returns>
    private IEnumerator CFadeInternal(float targetAlpha, float duration, bool blockRayCastsWhileFading)
    {
        float startAlpha = _fadeGroup.alpha;
        _fadeGroup.blocksRaycasts = blockRayCastsWhileFading;
        _fadeGroup.interactable = false;
        // 지속 시간이 0일 경우 즉시 전환
        if(duration <= 0f) {
            _fadeGroup.alpha = targetAlpha;
            _fadeGroup.blocksRaycasts = (targetAlpha >= 0.99f);
            yield break;
        }
        // 보간
        float t = 0f;
        while (t < duration) {
            float dt = _useUnscaledTime ? Time.unscaledDeltaTime : Time.deltaTime;
            t += dt;
            float lerp = Mathf.Clamp01(t / duration);
            _fadeGroup.alpha = Mathf.Lerp(startAlpha, targetAlpha, lerp);
            yield return null;
        }
        _fadeGroup.alpha = targetAlpha;
        _fadeGroup.blocksRaycasts = (targetAlpha >= 0.99f);
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Scene\SceneFlow.cs 
// ======================================================== 
 
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneFlow : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("카탈로그 등록")]
    [SerializeField] private SceneCatalog _catalog;
    [SerializeField] private SceneEffect _effect;

    [Header("옵션")]
    [SerializeField] private bool _enableHotKeys = true;
    [SerializeField] private bool _dontDestroyOnLoad = true;
    [SerializeField] private float _fadeDuration = 1.5f;
    [SerializeField] private bool _minimumTimeUse = true;

    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 변수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private static SceneFlow _instance;
    private int _cursorIndex = 0;
    private bool _isLoading = false;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private void SyncCursorToCurrentScene()
    {
        // 방어 코드
        List<SceneCatalog.SceneEntry> entries = _catalog.GetEntries();
        if (De.IsNull(entries)) return;
        if (De.IsTrue(entries.Count == 0)) return;
        // 현재 씬과 변수 매칭
        string currentName = SceneManager.GetActiveScene().name;
        for (int i = 0; i < entries.Count; ++i) {
            if (entries[i].name == currentName) {
                _cursorIndex = i;
                De.Print($"커서 싱크를 맞추었습니다. [ {_cursorIndex} / {currentName} ]");
                return;
            }
        }
        De.Print("커서 싱크를 실패했습니다.", LogType.Assert);
    }
    public void LoadScene(SceneCatalog.ESceneID id, float mininumTime)
    {
        // 방어 코드
        if (De.IsFalse(_catalog.TryGetSceneName(id, out string name)))
            return;
        if (De.IsTrue(string.IsNullOrEmpty(name)))
            return;
        // 연출과 함께 로딩
        StartCoroutine(CLoadSceneWithEffect(id, name, mininumTime));
    }
    private IEnumerator CLoadSceneWithEffect(SceneCatalog.ESceneID id, string name, float mininumTime)
    {
        if (De.IsTrue(_isLoading))
            yield break;
        ;
        // 비동기 씬 로드
        float nextTime = Time.time + mininumTime;
        AsyncOperation op = SceneManager.LoadSceneAsync(name);
        op.allowSceneActivation = false;
        while (op.progress < 0.9f) {
            yield return null;
        }
        De.Print($"씬 로드율이 90%에 도달했습니다. ({name})");
        if (_minimumTimeUse) {
            while (Time.time < nextTime) {
                yield return null;
            }
            De.Print($"씬 최소 재생 시간이 끝났습니다. ({name})");
        }
        // 페이드 아웃
        _isLoading = true;
        if (_effect != null) {
            yield return _effect.CFadeTo(1f, _fadeDuration);
        }
        op.allowSceneActivation = true;
        while (op.progress < 1f) {
            yield return null;
        }
        // 페이드 인
        if (_effect != null) {
            yield return _effect.CFadeTo(0f, _fadeDuration);
        }
        // 새로운 씬으로 변수 맞추기
        SyncCursorToCurrentScene();
        De.Print($"씬 로드가 완료되었습니다. ({name})");
        _isLoading = false;
    }
    private void ReloadCurrent()
    {
        // 카탈로그에 현재 씬이 없을 경우
        string current = SceneManager.GetActiveScene().name;
        if (De.IsFalse(_catalog.TryGetSceneID(current, out SceneCatalog.ESceneID id)))
            return;
        // 리로드
        De.Print($"씬({name}) 리로드를 시도합니다.");
        LoadScene(id, 0f);
    }
    public void LoadNext(float mininumTime)
    {
        // 방어 코드
        List<SceneCatalog.SceneEntry> entries = _catalog.GetEntries();
        if (De.IsNull(entries)) return;
        if (De.IsTrue(entries.Count == 0)) return;
        // 다음 씬으로 이동
        _cursorIndex++;
        if (entries.Count <= _cursorIndex)
            _cursorIndex = 0;
        string nextSceneName = entries[_cursorIndex].name;
        if(De.IsFalse(_catalog.TryGetSceneID(nextSceneName, out SceneCatalog.ESceneID id)) )
            return;
        De.Print($"다음 씬으로 이동합니다. ({_cursorIndex} → {nextSceneName})");
        LoadScene(id, mininumTime);
    }
    public void LoadPrev(float mininumTime)
    {
        // 방어 코드
        List<SceneCatalog.SceneEntry> entries = _catalog.GetEntries();
        if (De.IsNull(entries)) return;
        if (De.IsTrue(entries.Count == 0)) return;
        // 이전 씬으로 이동
        _cursorIndex--;
        if (_cursorIndex < 0)
            _cursorIndex = entries.Count - 1;
        string nextSceneName = entries[_cursorIndex].name;
        if(De.IsFalse(_catalog.TryGetSceneID(nextSceneName, out SceneCatalog.ESceneID id)) )
            return;
        De.Print($"이전 씬으로 이동합니다. ({_cursorIndex} → {nextSceneName})");
        LoadScene(id, mininumTime);
    }
    private void HandleHotKeys()
    {
        // 숫자 입력으로 특정 씬으로 이동
        if (Input.GetKeyDown(KeyCode.Alpha1))
            LoadScene(SceneCatalog.ESceneID.Manager, 0f);
        else if (Input.GetKeyDown(KeyCode.Alpha2))
            LoadScene(SceneCatalog.ESceneID.Title, 0f);
        else if (Input.GetKeyDown(KeyCode.Alpha3))
            LoadScene(SceneCatalog.ESceneID.Planet, 0f);
        else if (Input.GetKeyDown(KeyCode.Alpha4))
            LoadScene(SceneCatalog.ESceneID.GamePlay, 0f);
        else if (Input.GetKeyDown(KeyCode.Alpha5))
            LoadScene(SceneCatalog.ESceneID.GameEnd, 0f);
        // 대괄호 입력으로 앞 뒤 씬으로 이동
        else if (Input.GetKeyDown(KeyCode.LeftBracket))
            LoadNext(0f);
        else if (Input.GetKeyDown(KeyCode.RightBracket))
            LoadPrev(0f);
    }
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메시지 함수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private void Awake()
    {
        if (De.IsNull(_catalog) || De.IsNull(_effect)) {
            Destroy(gameObject);
            return;
        }
        // 중복 인스턴스 방지
        if (_instance != null && _instance != this) {
            De.Print("기존 인스턴스가 있으므로 현재 오브젝트를 제거합니다.");
            Destroy(gameObject);
            return;
        }
        // 싱글톤
        _instance = this;
        if (_dontDestroyOnLoad) {
            DontDestroyOnLoad(this.gameObject);
        }
        // 변수 정리
        _catalog.BuildMaps();
        SyncCursorToCurrentScene();
    }
    private void Start()
    {
        if (_effect != null)
            _effect.Initialize();
    }
    private void Update()
    {
        if (!_enableHotKeys) return;
        if (_isLoading) return;
        if (De.IsNull(_catalog)) return;

        HandleHotKeys();
    }
    // 인스턴스 정리
    private void OnDestroy()
    {
        if (_instance == this)
            _instance = null;
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Scene\SceneMover.cs 
// ======================================================== 
 
using UnityEngine;

public class SceneMover : MonoBehaviour
{
    [Header("필수 요소 등록")]
    [SerializeField] private SceneFlow _flow;
    [SerializeField] private SceneCatalog.ESceneID _id;
    [SerializeField] private float _minimum;

    private void Start()
    {
        _flow.LoadScene(_id, _minimum);
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Scene\TitleButton.cs 
// ======================================================== 
 
using UnityEngine;

public class TitleButton : MonoBehaviour
{
    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 인스펙터 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    [Header("필수 요소 등록")]
    [SerializeField] private SceneFlow _flow;
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 내부 메서드 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    public void OnClickPlay()
    {
        De.Print("플레이 버튼 클릭을 인식했습니다.");
        _flow.LoadScene(SceneCatalog.ESceneID.GamePlay, 0f);
    }

    public void OnClickQuit()
    {
        De.Print("게임 종료 버튼 클릭을 인식했습니다.");
        Application.Quit();
    }
    #endregion

    #region 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 메시지 함수 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
    private void Awake()
    {
        if (_flow == null) {
            _flow = GameObject.Find("SceneManager").GetComponent<SceneFlow>();
            if( De.IsNull(_flow)) {
                Destroy(gameObject);
            }
        }
    }
    #endregion
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Utility\De.cs 
// ======================================================== 
 
﻿#pragma warning disable IDE0060, CS0162
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Diagnostics;
using UnityEngine;

public static class De
{
    // 로그 출력 여부
#if UNITY_EDITOR || DEVELOPMENT_BUILD
    private const bool ENABLE_LOG = true;
    private const bool ENABLE_ONCE = false;
    private const bool ENABLE_PAUSE = false;
#else
    private const bool ENABLE_LOG = false;
    private const bool ENABLE_ONCE = true;
    private const bool ENABLE_PAUSE = false;
#endif
    #region 내부 멤버
    private static readonly HashSet<string> _logHistory = new HashSet<string>();

    // 플레이 모드가 시작될 때 자동으로 로그 기록을 초기화합니다.
    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]
    private static void ResetHistory()
    {
        _logHistory.Clear();
    }

    private static void LogInternal(string message, string file, int line, LogType type = LogType.Log)
    {
        if (!ENABLE_LOG)
            return;
        if (ENABLE_ONCE) {
            string key = file + line;
            if (_logHistory.Contains(key)) return;
            _logHistory.Add(key);
        }
        switch (type) {
            case LogType.Error:
            case LogType.Assert:
            case LogType.Exception:
                UnityEngine.Debug.LogError(message);
                break;
            case LogType.Warning:
                UnityEngine.Debug.LogWarning(message);
                break;
            default:
                UnityEngine.Debug.Log(message);
                break;
        }
        if (ENABLE_PAUSE) {
            UnityEngine.Debug.Break();
        }
    }
    #endregion

    #region 외부 공개 멤버
    /// <summary>
    /// 오브젝트가 Null 또는 Fake Null일 경우 True를 반환하고 로그를 출력합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsNull<T>(
        T obj,
        LogType logType = LogType.Warning,
        [CallerArgumentExpression("obj")] string objName = "",
        [CallerFilePath] string file = "",
        [CallerLineNumber] int line = 0)
    {
        bool isNull = false;
        // 검사
        if (obj is UnityEngine.Object unityObj) {
            isNull = unityObj == null;
        } else {
            isNull = obj == null;
        }
        // 로그
        if (isNull && ENABLE_LOG) {
            string msg = $"<color=red>[Null]</color> {objName} is Null";
            LogInternal(msg, file, line, logType);
        }
        return isNull;
    }

    /// <summary>
    /// 조건이 True일 경우 True를 반환하고 로그를 출력합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsTrue(
        bool condition,
        LogType logType = LogType.Warning,
        [CallerArgumentExpression("condition")] string message = "",
        [CallerFilePath] string file = "",
        [CallerLineNumber] int line = 0)
    {
        if (condition) {
            if (ENABLE_LOG) {
                LogInternal($"<color=red>[True]</color> {message}", file, line, logType);
            }
            return true;
        }
        return false;
    }

    /// <summary>
    /// 조건이 False일 경우 True를 반환하고 로그를 출력합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsFalse(
        bool condition,
        LogType logType = LogType.Warning,
        [CallerArgumentExpression("condition")] string message = "",
        [CallerFilePath] string file = "",
        [CallerLineNumber] int line = 0)
    {
        if (!condition)
        {
            if (ENABLE_LOG) {
                LogInternal($"<color=red>[False]</color> {message}", file, line, logType);
            }
            return true;
        }
        return false;
    }

    /// <summary>
    /// 로그를 출력합니다.
    /// </summary>
    [Conditional("UNITY_EDITOR"), Conditional("DEVELOPMENT_BUILD")]
    public static void Print(
        object message,
        LogType logType = LogType.Log,
        [CallerFilePath] string file = "",
        [CallerLineNumber] int line = 0)
    {
        LogInternal($"<color=cyan>[Log]</color> {message}", file, line, logType);
    }
    #endregion

    /// <summary>
    /// GUIStyle 변수에 접근합니다.
    /// </summary>
    private static GUIStyle _rectStyle;
    public static GUIStyle RectStyle
    {
        get {
            if (_rectStyle == null) {
                _rectStyle = new GUIStyle();
                _rectStyle.normal.textColor = Color.black;
                _rectStyle.alignment = TextAnchor.MiddleCenter;
            }
            return _rectStyle;
        }
    }

    public enum EWhere { LeftUp, Up, RightUp, Left, Center, Right, LeftDown, Down, RightDown }
    /// <summary>
    /// 게임 화면에 텍스트를 출력합니다.
    /// OnGUI 이벤트 내부에서 호출해야 합니다.
    /// </summary>
    /// <param name="text"></param>
    /// <param name="fontSize"></param>
    /// <param name="where"></param>
    public static void DrawText(string text, int fontSize = 30, EWhere where = EWhere.Up)
    {
        float w = Screen.width, h = Screen.height;
        float halfW = w * 0.5f, halfH = h * 0.5f;
        float x = 0, y = 0;
        // 가로 정렬
        switch (where) {
            case EWhere.LeftUp: case EWhere.Left: case EWhere.LeftDown:
            case EWhere.Up: case EWhere.Center: case EWhere.Down:
                x = 0; break;
            case EWhere.RightUp: case EWhere.Right: case EWhere.RightDown:
                x = halfW; break;
        }
        // 세로 정렬
        switch (where) {
            case EWhere.LeftUp: case EWhere.Up: case EWhere.RightUp: y = 0; break;
            case EWhere.Left: case EWhere.Center: case EWhere.Right: y = 0; break; // 전체 높이 사용
            case EWhere.LeftDown: case EWhere.Down: case EWhere.RightDown: y = halfH; break;
        }
        // 크기 설정
        float rectW = (where == EWhere.Center || where == EWhere.Up || where == EWhere.Down) ? w : halfW;
        float rectH = (where == EWhere.Center || where == EWhere.Left || where == EWhere.Right) ? h : halfH;

        RectStyle.fontSize = fontSize;
        GUI.Label(new Rect(x, y, rectW, rectH), text, RectStyle);
    }
}
// C# 최신 문법을 구버전에서 쓰기 위한 코드입니다.
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    internal sealed class CallerArgumentExpressionAttribute : Attribute
    {
        public CallerArgumentExpressionAttribute(string parameterName)
        {
            ParameterName = parameterName;
        }
        public string ParameterName { get; }
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Utility\Tool.cs 
// ======================================================== 
 
﻿using UnityEngine;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;
using UnityEngine.EventSystems;

public static class Tool
{
    #region 입력 & 좌표
    /// <summary>
    /// 화면 좌표를 월드 좌표(Z = 0)로 변환합니다.
    /// 카메라의 원근, 직교 여부에 상관없이 정확하게 동작합니다.
    /// </summary>
    /// <param name="camera"></param>
    /// <param name="screenPosition"></param>
    /// <returns></returns>
    public static Vector2 GetWorldPosition2D(this Camera camera, Vector3 screenPosition)
    {
        if (camera == null)
            return Vector2.zero;
        Plane plane = new Plane(Vector3.forward, Vector3.zero);
        Ray ray = camera.ScreenPointToRay(screenPosition);
        if (plane.Raycast(ray, out float distance)) {
            return (Vector2)ray.GetPoint(distance);
        }
        screenPosition.z = -camera.transform.position.z;
        return (Vector2)camera.ScreenToWorldPoint(screenPosition);
    }

    /// <summary>
    /// [오버로딩] 입력 좌표를 넣지 않으면 자동으로 현재 마우스 좌표를 사용합니다.
    /// (Legacy Input과 New Input System 모두 대응하기 위해 분리함)
    /// </summary>
    public static Vector2 GetMouseWorldPos(this Camera camera)
    {
#if ENABLE_INPUT_SYSTEM
        // 새로운 Input System 패키지를 쓴다면
        return GetWorldPosition2D(camera, UnityEngine.InputSystem.Mouse.current.position.ReadValue());
#else
        // 기존 Input Manager를 쓴다면
        return GetWorldPosition2D(camera, Input.mousePosition);
#endif
    }

    /// <summary>
    /// [유틸리티] 그리드(타일) 스냅 좌표를 반환합니다.
    /// 예: (1.2, 3.8) -> (1, 4) 또는 (1, 3) 
    /// </summary>
    /// <param name="cellSize">타일 크기 (기본 1)</param>
    public static Vector2Int GetGridPos(this Camera camera, float cellSize = 1.0f)
    {
        Vector2 worldPos = camera.GetMouseWorldPos();
        return new Vector2Int(
            Mathf.RoundToInt(worldPos.x / cellSize),
            Mathf.RoundToInt(worldPos.y / cellSize)
        );
    }

    /// <summary>
    /// [유틸리티] 마우스가 UI 위에 있는지 확인합니다. (클릭 관통 방지)
    /// </summary>
    public static bool IsPointerOverUI()
    {
        // PC/모바일 모두 작동하는 표준 방식
        return EventSystem.current != null && EventSystem.current.IsPointerOverGameObject();
    }

    /// <summary>
    /// 2D 게임에서 해당 카메라에서 마우스가 가리키는 월드 좌표를 반환합니다.
    /// </summary>
    public static Vector2 GetMousePos(Camera camera)
    {
        Vector3 mouse = Input.mousePosition;
        mouse.z = camera.transform.position.z;
        return (Vector2)camera.ScreenToWorldPoint(mouse);
    }

    /// <summary>
    /// 스크린 좌표를 2D 월드 좌표로 변환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 ScreenToWorld2D(Camera camera, Vector2 screenPos)
    {
        Vector3 pos = new Vector3(screenPos.x, screenPos.y, -camera.transform.position.z);
        return (Vector2)camera.ScreenToWorldPoint(pos);
    }

    /// <summary>
    /// 2D 월드 좌표를 스크린 좌표로 변환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 WorldToScreen2D(Camera camera, Vector2 worldPos)
    {
        return (Vector2)camera.WorldToScreenPoint(new Vector3(worldPos.x, worldPos.y, 0f));
    }
    #endregion


    // ================================================================
    //  컴포넌트 · 게임오브젝트
    // ================================================================

    /// <summary>
    /// 지정한 타입의 컴포넌트를 가져오거나 없으면 추가합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T GetOrAddComponent<T>(GameObject go) where T : Component
    {
        if (go == null) return null;
        T component = go.GetComponent<T>();
        if (component == null)
            component = go.AddComponent<T>();
        return component;
    }

    /// <summary>
    /// 부모 Transform의 모든 자식을 파괴합니다.
    /// </summary>
    public static void DestroyAllChildren(Transform parent)
    {
        if (parent == null) return;
        for (int i = parent.childCount - 1; i >= 0; --i) {
            UnityEngine.Object.Destroy(parent.GetChild(i).gameObject);
        }
    }

    /// <summary>
    /// 부모 Transform의 모든 자식을 즉시 파괴합니다. (에디터 전용)
    /// </summary>
    public static void DestroyAllChildrenImmediate(Transform parent)
    {
        if (parent == null) return;
        for (int i = parent.childCount - 1; i >= 0; --i) {
            UnityEngine.Object.DestroyImmediate(parent.GetChild(i).gameObject);
        }
    }

    /// <summary>
    /// 게임오브젝트의 활성 상태가 다를 때만 SetActive를 호출합니다.
    /// 불필요한 SetActive 호출로 인한 오버헤드를 방지합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void SetActiveIfNeeded(GameObject go, bool active)
    {
        if (go == null) return;
        if (go.activeSelf != active)
            go.SetActive(active);
    }

    // ================================================================
    //  레이어 · 태그
    // ================================================================

    /// <summary>
    /// 레이어 이름으로 LayerMask 비트를 생성합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int LayerToBit(string layerName)
    {
        return 1 << LayerMask.NameToLayer(layerName);
    }

    /// <summary>
    /// 여러 레이어 이름으로 복합 LayerMask 비트를 생성합니다.
    /// </summary>
    public static int LayersToBit(params string[] layerNames)
    {
        int mask = 0;
        for (int i = 0; i < layerNames.Length; ++i)
            mask |= 1 << LayerMask.NameToLayer(layerNames[i]);
        return mask;
    }

    /// <summary>
    /// 대상 게임오브젝트가 지정한 레이어에 속하는지 검사합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsInLayer(GameObject go, int layerMask)
    {
        if (go == null) return false;
        return (layerMask & (1 << go.layer)) != 0;
    }

    // ================================================================
    //  색상
    // ================================================================

    /// <summary>
    /// 색상의 알파값만 변경한 복사본을 반환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Color WithAlpha(Color color, float alpha)
    {
        color.a = alpha;
        return color;
    }

    /// <summary>
    /// HEX 문자열(#RRGGBB 또는 RRGGBB)을 Color로 변환합니다.
    /// 실패하면 Color.white를 반환합니다.
    /// </summary>
    public static Color HexToColor(string hex)
    {
        if (string.IsNullOrEmpty(hex))
            return Color.white;
        if (hex[0] == '#')
            hex = hex.Substring(1);
        if (hex.Length < 6)
            return Color.white;
        if (ColorUtility.TryParseHtmlString("#" + hex, out Color color))
            return color;
        return Color.white;
    }

    // ================================================================
    //  타이머 · 쿨다운
    // ================================================================

    /// <summary>
    /// 쿨다운이 끝났는지 검사합니다.
    /// Time.time 기준으로 nextTime보다 현재 시간이 크면 true를 반환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsCooldownReady(float nextTime)
    {
        return nextTime <= Time.time;
    }

    /// <summary>
    /// 쿨다운이 끝났는지 검사합니다.
    /// Time.unscaledTime 기준으로 nextTime보다 현재 시간이 크면 true를 반환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsCooldownReadyUnscaled(float nextTime)
    {
        return nextTime <= Time.unscaledTime;
    }

    /// <summary>
    /// 쿨다운을 소비합니다.
    /// 쿨다운이 끝났으면 nextTime을 갱신하고 true를 반환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryCooldown(ref float nextTime, float interval)
    {
        if (Time.time < nextTime)
            return false;
        nextTime = Time.time + interval;
        return true;
    }

    /// <summary>
    /// 스케일 영향을 받지 않는 쿨다운을 소비합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryCooldownUnscaled(ref float nextTime, float interval)
    {
        if (Time.unscaledTime < nextTime)
            return false;
        nextTime = Time.unscaledTime + interval;
        return true;
    }

    // ================================================================
    //  확률 · 가중치 랜덤
    // ================================================================

    /// <summary>
    /// 0~1 범위의 확률 검사입니다. chance가 0.3이면 30% 확률로 true를 반환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Chance(float chance)
    {
        return UnityEngine.Random.value < chance;
    }

    /// <summary>
    /// 가중치 배열에서 가중치 기반 랜덤 인덱스를 반환합니다.
    /// 모든 가중치가 0 이하이면 -1을 반환합니다.
    /// </summary>
    public static int WeightedRandom(float[] weights)
    {
        if (weights == null || weights.Length == 0) return -1;
        float total = 0f;
        for (int i = 0; i < weights.Length; ++i) {
            if (weights[i] > 0f)
                total += weights[i];
        }
        if (total <= 0f) return -1;
        float random = UnityEngine.Random.Range(0f, total);
        float cumulative = 0f;
        for (int i = 0; i < weights.Length; ++i) {
            if (weights[i] <= 0f) continue;
            cumulative += weights[i];
            if (random < cumulative)
                return i;
        }
        return weights.Length - 1;
    }

    /// <summary>
    /// int 가중치 배열에서 가중치 기반 랜덤 인덱스를 반환합니다.
    /// 모든 가중치가 0 이하이면 -1을 반환합니다.
    /// </summary>
    public static int WeightedRandom(int[] weights)
    {
        if (weights == null || weights.Length == 0) return -1;
        int total = 0;
        for (int i = 0; i < weights.Length; ++i) {
            if (weights[i] > 0)
                total += weights[i];
        }
        if (total <= 0) return -1;
        int random = UnityEngine.Random.Range(0, total);
        int cumulative = 0;
        for (int i = 0; i < weights.Length; ++i) {
            if (weights[i] <= 0) continue;
            cumulative += weights[i];
            if (random < cumulative)
                return i;
        }
        return weights.Length - 1;
    }

    // ================================================================
    //  문자열
    // ================================================================

    /// <summary>
    /// 큰 숫자를 축약 표기합니다. (1000 → 1K, 1500000 → 1.5M)
    /// </summary>
    public static string ToAbbreviated(long number)
    {
        if (number < 1000L)
            return number.ToString();
        if (number < 1000000L)
            return (number / 1000f).ToString("0.#") + "K";
        if (number < 1000000000L)
            return (number / 1000000f).ToString("0.#") + "M";
        return (number / 1000000000f).ToString("0.#") + "B";
    }

    /// <summary>
    /// 초를 MM:SS 형식의 문자열로 변환합니다.
    /// </summary>
    public static string ToTimeMMSS(float seconds)
    {
        if (seconds < 0f) seconds = 0f;
        int min = (int)(seconds / 60f);
        int sec = (int)(seconds % 60f);
        return $"{min:D2}:{sec:D2}";
    }

    /// <summary>
    /// 초를 HH:MM:SS 형식의 문자열로 변환합니다.
    /// </summary>
    public static string ToTimeHHMMSS(float seconds)
    {
        if (seconds < 0f) seconds = 0f;
        int hour = (int)(seconds / 3600f);
        int min = (int)((seconds % 3600f) / 60f);
        int sec = (int)(seconds % 60f);
        return $"{hour:D2}:{min:D2}:{sec:D2}";
    }

    // ================================================================
    //  스프라이트렌더러 · UI
    // ================================================================

    /// <summary>
    /// SpriteRenderer의 알파값을 변경합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void SetSpriteAlpha(SpriteRenderer renderer, float alpha)
    {
        if (renderer == null) return;
        Color c = renderer.color;
        c.a = alpha;
        renderer.color = c;
    }

    /// <summary>
    /// CanvasGroup의 표시/숨김을 한 번에 처리합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void SetCanvasGroupVisible(CanvasGroup group, bool visible)
    {
        if (group == null) return;
        group.alpha = visible ? 1f : 0f;
        group.interactable = visible;
        group.blocksRaycasts = visible;
    }

    // ================================================================
    //  2D 물리
    // ================================================================

    /// <summary>
    /// 2D 원형 범위 안에 있는 모든 콜라이더를 NonAlloc으로 검출합니다.
    /// 결과 배열은 내부에서 재사용됩니다. 즉시 사용하세요.
    /// </summary>
    private static readonly Collider2D[] _overlapBuffer = new Collider2D[64];

    public static int OverlapCircle2D(Vector2 center, float radius, int layerMask, Collider2D[] resultBuffer)
    {
        if (resultBuffer == null) return 0;
        return Physics2D.OverlapCircleNonAlloc(center, radius, resultBuffer, layerMask);
    }

    /// <summary>
    /// 2D 원형 범위 안에 있는 모든 콜라이더를 내부 버퍼로 검출합니다.
    /// 반환된 count만큼 GetOverlapBuffer()로 접근하세요.
    /// </summary>
    public static int OverlapCircle2D(Vector2 center, float radius, int layerMask)
    {
        return Physics2D.OverlapCircleNonAlloc(center, radius, _overlapBuffer, layerMask);
    }

    /// <summary>
    /// 내부 오버랩 버퍼를 반환합니다.
    /// OverlapCircle2D(center, radius, layerMask)와 함께 사용하세요.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Collider2D[] GetOverlapBuffer()
    {
        return _overlapBuffer;
    }

    // ================================================================
    //  애플리케이션
    // ================================================================

    public static void GameStop()
    {
#if UNITY_EDITOR
        UnityEditor.EditorApplication.isPlaying = false;
#else
        Application.Quit();
#endif
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Utility\UArray.cs 
// ======================================================== 
 
﻿using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
/// <summary>
/// 배열과 리스트를 다루는 유틸리티입니다.
/// </summary>
public static class UArray
{
    /// <summary>
    /// 배열 크기를 조정하며, 성공 여부에 따라 True 또는 False를 반환합니다.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="targetArray"></param>
    /// <param name="multiplySize"></param>
    /// <returns></returns>
    public static bool TryResizeArray<T>(ref T[] targetArray, double multiplySize)
    {
        if (De.IsNull(targetArray, LogType.Exception))
            return false;
        long newSize = (long)(targetArray.Length * multiplySize);
        if (int.MaxValue < newSize) {
            if (newSize <= 0) {
                De.Print("배열의 크기가 0 이하입니다.", LogType.Exception);
                return false;
            }
            if (targetArray.Length == int.MaxValue) {
                De.Print("더 이상 배열을 확장할 수 없습니다.", LogType.Exception);
                return false;
            }
            newSize = (long)int.MaxValue;
        }
        try {
            Array.Resize(ref targetArray, (int)newSize);
            return true;
        }
        catch (OutOfMemoryException) {
            De.Print("메모리가 부족하여 배열을 확장할 수 없습니다.");
            return false;
        }
    }

    /// <summary>
    /// 피셔 예이츠 셔플로 배열을 무작위로 섞습니다.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="array"></param>
    public static void Shuffle<T>(this T[] array)
    {
        if (array == null)
            return;
        int length = array.Length - 1;
        for (int i = length; i > 0; --i) {
            int j = UnityEngine.Random.Range(0, i + 1);

            T tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
        }
    }

    /// <summary>
    /// 피셔 예이츠 셔플로 리스트를 무작위로 섞습니다.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="list"></param>
    public static void Shuffle<T>(this List<T> list)
    {
        if (list == null)
            return;
        int length = list.Count - 1;
        for (int i = length; i > 0; --i) {
            int j = UnityEngine.Random.Range(0, i + 1);
            T tmp = list[i];
            list[i] = list[j];
            list[j] = tmp;
        }
    }

    /// <summary>
    /// 리스트의 마지막 요소와 교체하고, 마지막 요소를 삭제합니다.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="list"></param>
    /// <param name="index"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void SwapLastAndRemove<T>(this List<T> list, int index)
    {
        if (list == null)
            return;
        int last = list.Count - 1;
        if (index < 0 || last < index)
            return;
        list[index] = list[last];
        list.RemoveAt(last);
    }

    /// <summary>
    /// 리스트와 각 요소가 모두 초기화되어 있다면 True를 반환합니다.
    /// False일 경우 De 클래스로 로그를 출력합니다.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="list"></param>
    /// <returns></returns>
    public static bool IsInitedList<T>(List<T> list)
    {
        if (De.IsNull(list, LogType.Exception))
            return false;
        int count = list.Count;
        if (De.IsTrue(count <= 0, LogType.Exception))
            return false;
        if (De.IsTrue(list.Capacity <= 0, LogType.Exception))
            return false;
        for (int i = 0; i < count; ++i) {
            if (De.IsNull(list[i], LogType.Exception))
                return false;
        }
        return true;
    }

    /// <summary>
    /// 1차원 배열과 각 요소가 모두 초기화되어 있다면 True를 반환합니다.
    /// False일 경우 De 클래스로 로그를 출력합니다.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="array"></param>
    /// <returns></returns>
    public static bool IsInitedArray<T>(T[] array)
    {
        if (De.IsNull(array, LogType.Exception))
            return false;
        int length = array.Length;
        if (De.IsTrue(length == 0, LogType.Exception))
            return false;
        // 값 형식
        if (typeof(T).IsValueType)
            return true;
        // 참조 형식
        for (int i = 0; i < length; ++i) {
            if (De.IsNull(array[i], LogType.Exception))
                return false;
        }
        return true;
    }

    /// <summary>
    /// 인덱스가 배열 범위 안에 있는지 검사합니다.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="array"></param>
    /// <param name="index"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InBounds<T>(T[] array, int index)
    {
        if (array == null)
            return false;
        if (index < array.Length)
            return false;
        if (0 <= index)
            return false;
        return true;
    }

    /// <summary>
    /// 인덱스가 리스트 범위 안에 있는지 검사합니다.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="list"></param>
    /// <param name="index"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InBounds<T>(List<T> list, int index)
    {
        if (list == null)
            return false;
        if (index < list.Count)
            return false;
        if (0 <= index)
            return false;
        return true;
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Utility\UGraphic.cs 
// ======================================================== 
 
﻿using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

/// <summary>
/// 렌더링에 필요한 공통 유틸리티입니다.
/// Material 캐싱, 배치 데이터 관리, 좌표 변환 등을 제공합니다.
/// </summary>
public static class UGraphic
{
    /// <summary>
    /// ERotation를 Z축 회전 각도(도)로 변환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float RotateToAngle(ERotation rotate)
    {
        switch (rotate) {
            case ERotation.Up: return 0f;
            case ERotation.Left: return 90f;
            case ERotation.Down: return 180f;
            case ERotation.Right: return 270f;
            default: return 0f;
        }
    }

    /// <summary>
    /// ERotation를 Quaternion으로 변환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Quaternion RotateToQuaternion(ERotation rotate)
    {
        return Quaternion.Euler(0f, 0f, RotateToAngle(rotate));
    }

    /// <summary>
    /// 각도(도)를 Quaternion으로 변환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Quaternion AngleToQuaternion(float degree)
    {
        return Quaternion.Euler(0f, 0f, degree);
    }

    /// <summary>
    /// 위치, 회전, 크기로 TRS 행렬을 생성합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Matrix4x4 BuildMatrix(Vector3 pos, Quaternion rot, Vector3 scale)
    {
        return Matrix4x4.TRS(pos, rot, scale);
    }

    /// <summary>
    /// 위치와 크기로 회전 없는 TRS 행렬을 생성합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Matrix4x4 BuildMatrix(Vector3 pos, Vector3 scale)
    {
        return Matrix4x4.TRS(pos, Quaternion.identity, scale);
    }

    /// <summary>
    /// 기본 머티리얼과 스프라이트로 새로운 머티리얼을 생성합니다.
    /// </summary>
    public static Material CreateMaterial(Material baseMaterial, Sprite sprite)
    {
        Material mat = new Material(baseMaterial);
        mat.mainTexture = sprite.texture;
        return mat;
    }

    /// <summary>
    /// 중심점을 기준으로 오프셋을 특정 각도(도)만큼 회전시킨 월드 좌표를 반환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector3 RotateOffset(float centerX, float centerY, float offsetX, float offsetY, float degree, float z)
    {
        float radian = degree * Mathf.Deg2Rad;
        float cos = Mathf.Cos(radian);
        float sin = Mathf.Sin(radian);
        float rotX = offsetX * cos - offsetY * sin;
        float rotY = offsetX * sin + offsetY * cos;
        return new Vector3(centerX + rotX, centerY + rotY, z);
    }

    private static Stack<List<Matrix4x4>> _listPool = new Stack<List<Matrix4x4>>();

    /// <summary>
    /// 풀에서 리스트를 꺼내오거나, 없으면 새로 만듭니다.
    /// </summary>
    private static List<Matrix4x4> GetListFromPool()
    {
        if (_listPool.Count > 0)
            return _listPool.Pop();
        return new List<Matrix4x4>(1000);
    }

    /// <summary>
    /// 다 쓴 리스트를 풀에 반납합니다.
    /// </summary>
    private static void ReturnListToPool(List<Matrix4x4> list)
    {
        list.Clear();
        _listPool.Push(list);
    }

    public static void ClearBatches<TKey>(
        Dictionary<TKey, List<List<Matrix4x4>>> batchMap,
        List<TKey> activeKeys)
    {
        for (int i = 0; i < activeKeys.Count; i++) {
            var key = activeKeys[i];
            if (batchMap.TryGetValue(key, out var lists)) {
                for (int j = 0; j < lists.Count; j++) {
                    ReturnListToPool(lists[j]);
                }
                lists.Clear();
            }
        }
        activeKeys.Clear();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void AddMatrix<TKey>(
        Dictionary<TKey, List<List<Matrix4x4>>> batchMap,
        List<TKey> keys,
        TKey key,
        Matrix4x4 matrix,
        int batchLimit = 1000)
    {
        List<List<Matrix4x4>> lists;
        if (!batchMap.TryGetValue(key, out lists)) {
            lists = new List<List<Matrix4x4>>();
            batchMap.Add(key, lists);
        }

        if (lists.Count == 0) {
            lists.Add(GetListFromPool());
            keys.Add(key);
        }

        List<Matrix4x4> curList = lists[lists.Count - 1];

        if (batchLimit <= curList.Count) {
            curList = GetListFromPool();
            lists.Add(curList);
        }

        curList.Add(matrix);
    }

    /// <summary>
    /// batchMap에 저장된 렌더링 데이터를 DrawMeshInstanced로 그립니다.
    /// </summary>
    public static void DrawBatches<TKey>(
        Mesh mesh,
        Dictionary<TKey, List<List<Matrix4x4>>> batchMap,
        List<TKey> activeKeys,
        Dictionary<TKey, Material> materialCache)
    {
        for (int i = 0; i < activeKeys.Count; ++i) {
            TKey key = activeKeys[i];
            if (!materialCache.TryGetValue(key, out Material mat))
                continue;
            var lists = batchMap[key];
            for (int j = 0; j < lists.Count; ++j) {
                if (lists[j].Count <= 0)
                    continue;
                Graphics.DrawMeshInstanced(mesh, 0, mat, lists[j]);
            }
        }
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Utility\UGrid.cs 
// ======================================================== 
 
﻿using System;
using System.Runtime.CompilerServices;
using UnityEngine;

/// <summary>
/// 격자 좌표 변환 및 검증하는 유틸리티입니다.
/// </summary>
public class UGrid
{
    /// <summary>
    /// 월드 좌표를 그리드 좌표로 변환하여 반환합니다.
    /// </summary>
    /// <param name="pos"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2Int WorldToGrid(Vector2 pos)
    {
        pos.x = Mathf.FloorToInt(pos.x);
        pos.y = Mathf.FloorToInt(pos.y);
        return new Vector2Int((int)pos.x, (int)pos.y);
    }

    /// <summary>
    /// 월드 좌표를 그리드 좌표로 변환하여 반환합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (int x, int y) WorldToGrid(float x, float y)
    {
        int nX = Mathf.FloorToInt(x);
        int nY = Mathf.FloorToInt(y);
        return (nX, nY);
    }

    /// <summary>
    /// 월드 좌표를 격자 배열에서 사용할 인덱스로 변환합니다.
    /// </summary>
    /// <param name="pos"></param>
    /// <param name="width"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int WorldToIndex(Vector2 pos, int width)
    {
        int nX = Mathf.FloorToInt(pos.x);
        int nY = Mathf.FloorToInt(pos.y);
        return GridToIndex(nX, nY, width);
    }

    /// <summary>
    /// 월드 좌표를 격자 배열에서 사용할 인덱스로 변환합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="width"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int WorldToIndex(float x, float y, int width)
    {
        x = Mathf.FloorToInt(x);
        y = Mathf.FloorToInt(y);
        return GridToIndex(x, y, width);
    }

    /// <summary>
    /// 그리드 좌표를 월드 좌표로 변환하여 중심점을 반환합니다.
    /// </summary>
    /// <param name="pos"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 GridToWorld(Vector2 pos)
    {
        pos.x += 0.5f;
        pos.y += 0.5f;
        return pos;
    }

    /// <summary>
    /// 그리드 좌표를 월드 좌표로 변환하여 중심점을 반환합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (float x, float y) GridToWorld(float x, float y)
    {
        x += 0.5f;
        y += 0.5f;
        return (x, y);
    }

    /// <summary>
    /// 그리드 좌표 성분을 월드 좌표로 변환하여 중심점을 반환합니다.
    /// </summary>
    /// <param name="coordinate"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float GridToWorld(float coordinate)
    {
        return coordinate + 0.5f;
    }

    /// <summary>
    /// 좌표를 격자 배열에서 사용할 인덱스로 변환합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="width"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GridToIndex(int x, int y, int width)
    {
        return (y * width) + x;
    }

    /// <summary>
    /// 좌표를 격자 배열에서 사용할 인덱스로 변환합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="width"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GridToIndex(float x, float y, int width)
    {
        int gridX, gridY;
        (gridX, gridY) = WorldToGrid(x, y);
        return (gridY * width) + gridX;
    }

    /// <summary>
    /// 좌표를 격자 배열에서 사용할 인덱스로 변환합니다.
    /// </summary>
    /// <param name="pos"></param>
    /// <param name="width"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GridToIndex(Vector2 pos, int width)
    {
        pos = WorldToGrid(pos);
        return ((int)pos.y * width) + (int)pos.x;
    }

    /// <summary>
    /// 인덱스를 격자 배열 좌표로 변환합니다.
    /// </summary>
    /// <param name="index"></param>
    /// <param name="width"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (int x, int y) IndexToGrid(int index, int width)
    {
        int x = index % width;
        int y = index / width;
        return (x, y);
    }

    /// <summary>
    /// 인덱스를 격자 배열 좌표로 변환합니다.
    /// </summary>
    /// <param name="index"></param>
    /// <param name="width"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 IndexToGridV(int index, int width)
    {
        int x = index % width;
        int y = index / width;
        return new Vector2(x, y);
    }

    /// <summary>
    /// 인덱스를 월드 좌표로 변환합니다.
    /// </summary>
    /// <param name="index"></param>
    /// <param name="width"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (float x, float y) IndexToWorld(int index, int width)
    {
        (int x, int y) = IndexToGrid(index, width);
        float fX = x + 0.5f;
        float fY = y + 0.5f;
        return (fX, fY);
    }

    /// <summary>
    /// 인덱스를 월드 좌표로 변환합니다.
    /// </summary>
    /// <param name="index"></param>
    /// <param name="width"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 IndexToWorldV(int index, int width)
    {
        (int x, int y) = IndexToGrid(index, width);
        return new Vector2(x + 0.5f, y + 0.5f);
    }

    /// <summary>
    /// 좌표가 맵 안에 있는지 검사합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InMap(int x, int y, int width, int height)
    {
        if (x < 0) return false;
        if (y < 0) return false;
        if (width <= x) return false;
        if (height <= y) return false;
        return true;
    }

    /// <summary>
    /// 좌표가 맵 안에 있는지 검사합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InMap(float x, float y, int width, int height)
    {
        if (x < 0f) return false;
        if (y < 0f) return false;
        if ((float)width <= x) return false;
        if ((float)height <= y) return false;
        return true;
    }

    /// <summary>
    /// 좌표가 맵 안에 있는지 검사합니다.
    /// </summary>
    /// <param name="pos"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InMap(int index, int width, int height)
    {
        if (index < 0) return false;
        if (width * height < index) return false;
        return true;
    }

    /// <summary>
    /// 좌표가 맵 안에 있는지 검사합니다.
    /// </summary>
    /// <param name="pos"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InMap(Vector2 pos, int width, int height)
    {
        if (pos.x < 0f) return false;
        if (pos.y < 0f) return false;
        if ((float)width <= pos.x) return false;
        if ((float)height <= pos.y) return false;
        return true;
    }

    /// <summary>
    /// 실수 좌표를 맵 범위 안으로 클램프합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (float x, float y) ClampMap(float x, float y, int width, int height)
    {
        x = Mathf.Clamp(x, 0.001f, (float)width - 0.001f);
        y = Mathf.Clamp(y, 0.001f, (float)height - 0.001f);
        return (x, y);
    }

    /// <summary>
    /// 실수 좌표를 맵 범위 안으로 클램프합니다.
    /// </summary>
    /// <param name="pos"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 ClampMap(Vector2 pos, int width, int height)
    {
        pos.x = Mathf.Clamp(pos.x, 0.001f, (float)width - 0.001f);
        pos.y = Mathf.Clamp(pos.y, 0.001f, (float)height - 0.001f);
        return pos;
    }

    /// <summary>
    /// 정수 좌표를 맵 범위 안으로 클램프합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (int x, int y) ClampMap(int x, int y, int width, int height)
    {
        x = Mathf.Clamp(x, 0, width - 1);
        y = Mathf.Clamp(y, 0, height - 1);
        return (x, y);
    }

    /// <summary>
    /// 회전 열거형을 시계 방향으로 90도 회전하여 반환합니다.
    /// </summary>
    /// <param name="rotation"></param>
    /// <returns></returns>
    public static ERotation ClockwisERotation(ERotation rotation)
    {
        if (rotation == ERotation.Up)
            return ERotation.Right;
        if (rotation == ERotation.Right)
            return ERotation.Down;
        if (rotation == ERotation.Down)
            return ERotation.Left;
        if (rotation == ERotation.Left)
            return ERotation.Up;
        return ERotation.None;
    }

    /// <summary>
    /// 회전 열거형을 반시계 방향으로 90도 회전하여 반환합니다.
    /// </summary>
    /// <param name="rotation"></param>
    /// <returns></returns>
    public static ERotation CounterClockwisERotation(ERotation rotation)
    {
        if (rotation == ERotation.Up)
            return ERotation.Left;
        if (rotation == ERotation.Left)
            return ERotation.Down;
        if (rotation == ERotation.Down)
            return ERotation.Right;
        if (rotation == ERotation.Right)
            return ERotation.Up;
        return ERotation.None;
    }

    /// <summary>
    /// 블록의 방향을 고려하여 블록이 점유한 셀을 순환할 수 있는 변수를 반환받습니다.
    /// 기본값 : 왼쪽 아래
    /// </summary>
    /// <param name="index"></param>
    /// <param name="size"></param>
    /// <param name="dir"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (int startX, int endX, int startY, int endY)
        GetLoopBlock(int index, Vector2 size, ERotation rotate, int width, int height)
    {
        (int x, int y) = IndexToGrid(index, width);
        int sizeX = (int)size.x;
        int sizeY = (int)size.y;
        int halfX = sizeX / 2;
        int halfY = sizeY / 2;

        int startX = x - halfX;
        int endX = x + halfX;
        int startY = y - halfY;
        int endY = y + halfY;

        // 가로 길이 짝수
        if ((sizeX & 1) == 0) {
            if (rotate == ERotation.Right) startX++;
            else endX--;
        }
        // 세로 길이 짝수
        if ((sizeY & 1) == 0) {
            if (rotate == ERotation.Up) startY++;
            else endY--;
        }
        // 인덱스 벗어나지 않도록
        (startX, startY) = ClampMap(startX, startY, width, height);
        (endX, endY) = ClampMap(endX, endY, width, height);
        // 완료
        return (startX, endX, startY, endY);
    }

    /// <summary>
    /// 유닛이 점유한 셀을 순환할 수 있는 변수를 반환받습니다.
    /// </summary>
    /// <param name="pos"></param>
    /// <param name="size"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (int startX, int endX, int startY, int endY)
        GetLoopUnit(Vector2 pos, Vector2 size, int width, int height)
    {
        float halfX = size.x * 0.5f;
        float halfY = size.y * 0.5f;
        int startX = (int)(pos.x - halfX);
        int endX = (int)(pos.x + halfX);
        int startY = (int)(pos.y - halfY);
        int endY = (int)(pos.y + halfY);
        (startX, startY) = ClampMap(startX, startY, width, height);
        (endX, endY) = ClampMap(endX, endY, width, height);
        // 완료
        return (startX, endX, startY, endY);
    }

    /// <summary>
    /// 좌표가 특정 그리드 안에 있는지 검사합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="gridX"></param>
    /// <param name="gridY"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InGrid(float x, float y, int gridX, int gridY)
    {
        float left = (float)gridX;
        float right = (float)gridX + 1f;
        float down = (float)gridY;
        float up = (float)gridY + 1f;
        if (x < left) return false;
        if (y < down) return false;
        if (right <= x) return false;
        if (up <= y) return false;
        return true;
    }

    /// <summary>
    /// 좌표가 특정 그리드 안에 있는지 검사합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="gridX"></param>
    /// <param name="gridY"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InGrid(Vector2 pos, int gridX, int gridY)
    {
        float left = (float)gridX;
        float right = (float)gridX + 1f;
        float down = (float)gridY;
        float up = (float)gridY + 1f;
        if (pos.x < left) return false;
        if (pos.y < down) return false;
        if (right <= pos.x) return false;
        if (up <= pos.y) return false;
        return true;
    }

    /// <summary>
    /// 정확한 값의 방향 벡터를 열거형으로 변환합니다.
    /// </summary>
    /// <param name="dir"></param>
    /// <returns></returns>
    public static ERotation DirToRotate(Vector2 dir)
    {
        if (dir == Vector2.up)
            return ERotation.Up;
        else if (dir == Vector2.right)
            return ERotation.Right;
        else if (dir == Vector2.down)
            return ERotation.Down;
        else if (dir == Vector2.left)
            return ERotation.Left;
        De.Print("존재하지 않는 방향이 감지되었습니다. GetDirection4가 제대로 일 안하는 듯", LogType.Assert);
        return ERotation.None;
    }

    /// <summary>
    /// 4방향 인접 셀을 순회하며 액션(x, y)을 실행합니다.
    /// </summary>
    /// <param name="gridX"></param>
    /// <param name="gridY"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <param name="action"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ForeachAdjacentCells4(int gridX, int gridY, int width, int height, Action<int, int> action)
    {
        if (1 <= gridX) action(gridX - 1, gridY);
        if (1 <= gridY) action(gridX, gridY - 1);
        if (gridX < width - 1) action(gridX + 1, gridY);
        if (gridY < height - 1) action(gridX, gridY + 1);
    }

    /// <summary>
    /// 8방향 인접 셀을 순회하며 액션(x, y)을 실행합니다.
    /// </summary>
    /// <param name="gridX"></param>
    /// <param name="gridY"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <param name="action"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ForeachAdjacentCells8(int gridX, int gridY, int width, int height, Action<int, int> action)
    {
        if (1 <= gridX) {
            int leftX = gridX - 1;
            action(leftX, gridY); // 왼쪽
            if (1 <= gridY) action(leftX, gridY - 1); // 왼쪽 위
            if (gridY < height - 1) action(leftX, gridY + 1); // 왼쪽 아래
        }
        if (gridX < width - 1) {
            int rightX = gridX + 1;
            action(rightX, gridY); // 오른쪽
            if (1 <= gridY) action(rightX, gridY - 1); // 오른쪽 위
            if (gridY < height - 1) action(rightX, gridY + 1); // 오른쪽 아래
        }
        // 위, 아래
        if (1 <= gridY) action(gridX, gridY - 1);
        if (gridY < height - 1) action(gridX, gridY + 1);
    }

    /// <summary>
    /// 두 좌표를 받아서 점유한 블록을 점유할 수 있도록 변수를 반환합니다.
    /// </summary>
    /// <param name="startPos"></param>
    /// <param name="endPos"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (int minX, int minY, int maxX, int maxY) GetForeachPos(Vector2 startPos, Vector2 endPos)
    {
        Vector2 startGrid = WorldToGrid(startPos);
        Vector2 endGrid = WorldToGrid(endPos);
        (startGrid, endGrid) = UMath.SortNumericSize(startGrid, endGrid);
        int minX = (int)startGrid.x;
        int minY = (int)startGrid.y;
        int maxX = (int)endGrid.x;
        int maxY = (int)endGrid.y;
        return (minX, minY, maxX, maxY);
    }

    /// <summary>
    /// ERotation을 각도(도)로 변환합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float RotationToAngle(ERotation rotation)
    {
        switch (rotation) {
            case ERotation.Up: return 0f;
            case ERotation.Right: return -90f;
            case ERotation.Down: return -180f;
            case ERotation.Left: return -270f;
            default: return 0f;
        }
    }

    /// <summary>
    /// ERotation을 시계 방향으로 90도 회전합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ERotation RotateCW(ERotation rotation)
    {
        switch (rotation) {
            case ERotation.Up: return ERotation.Right;
            case ERotation.Right: return ERotation.Down;
            case ERotation.Down: return ERotation.Left;
            case ERotation.Left: return ERotation.Up;
            default: return ERotation.Up;
        }
    }

    /// <summary>
    /// ERotation을 반시계 방향으로 90도 회전합니다.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ERotation RotateCCW(ERotation rotation)
    {
        switch (rotation) {
            case ERotation.Up: return ERotation.Left;
            case ERotation.Left: return ERotation.Down;
            case ERotation.Down: return ERotation.Right;
            case ERotation.Right: return ERotation.Up;
            default: return ERotation.Up;
        }
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Utility\UMath.cs 
// ======================================================== 
 
﻿using System.Runtime.CompilerServices;
using UnityEngine;
/// <summary>
/// 수학 관련 연산을 돕는 유틸리티입니다.
/// </summary>
public class UMath : MonoBehaviour
{
    /// <summary>
    /// Sharpness 변수를 기준으로 지수 보간한 값(0 ~ 1)을 반환합니다.
    /// </summary>
    /// <param name="sharpness"></param>
    /// <param name="deltatime"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float GetSmoothT(float sharpness, float deltatime)
    {
        return 1f - Mathf.Exp(-sharpness * deltatime);
    }

    /// <summary>
    /// 두 벡터의 각 요소를 비교해서 가장 작은 벡터와 가장 큰 벡터를 반환합니다.
    /// </summary>
    /// <param name="pos1"></param>
    /// <param name="pos2"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (Vector2 minPos, Vector2 maxPos) SortNumericSize(Vector2 pos1, Vector2 pos2)
    {
        if (pos2.x <= pos1.x) {
            float tmp = pos1.x;
            pos1.x = pos2.x;
            pos2.x = tmp;
        }
        if (pos2.y <= pos1.y) {
            float tmp = pos1.y;
            pos1.y = pos2.y;
            pos2.y = tmp;
        }
        return (pos1, pos2);
    }

    /// <summary>
    /// 두 벡터의 각 요소를 비교해서 가장 작은 벡터와 가장 큰 벡터를 반환합니다.
    /// </summary>
    /// <param name="pos1"></param>
    /// <param name="pos2"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (Vector2Int minPos, Vector2Int maxPos) SortNumericSize(Vector2Int pos1, Vector2Int pos2)
    {
        if (pos2.x <= pos1.x) {
            int tmp = pos1.x;
            pos1.x = pos2.x;
            pos2.x = tmp;
        }
        if (pos2.y <= pos1.y) {
            int tmp = pos1.y;
            pos1.y = pos2.y;
            pos2.y = tmp;
        }
        return (pos1, pos2);
    }

    /// <summary>
    /// 두 좌표를 비교해서 가장 작은 좌표와 가장 큰 좌표를 반환합니다.
    /// </summary>
    /// <param name="pos1"></param>
    /// <param name="pos2"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (float minX, float maxX, float minY, float maxY) SortNumericSize(float x1, float y1, float x2, float y2)
    {
        if (x2 <= x1) {
            float tmp = x1;
            x1 = x2;
            x2 = tmp;
        }
        if (y2 <= y1) {
            float tmp = y1;
            y1 = y2;
            y2 = tmp;
        }
        return (x1, x2, x1, x2);
    }

    /// <summary>
    /// 두 좌표를 격자 형태의 도로망에서 최단 거리를 계산하여 반환합니다.
    /// </summary>
    /// <param name="x1"></param>
    /// <param name="y1"></param>
    /// <param name="x2"></param>
    /// <param name="y2"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float GetManhattanDist(float x1, float y1, float x2, float y2)
    {
        return Mathf.Abs(x1 - x2) + Mathf.Abs(y1 - y2);
    }

    /// <summary>
    /// 두 좌표를 격자 형태의 도로망에서 최단 거리를 계산하여 반환합니다.
    /// </summary>
    /// <param name="pos1"></param>
    /// <param name="pos2"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float GetManhattanDist(Vector2 pos1, Vector2 pos2)
    {
        return Mathf.Abs(pos1.x - pos2.x) + Mathf.Abs(pos1.y - pos2.y);
    }

    /// <summary>
    /// 두 좌표를 2D 평면에서 최단 거리로 계산하여 반환합니다.
    /// </summary>
    /// <param name="x1"></param>
    /// <param name="y1"></param>
    /// <param name="x2"></param>
    /// <param name="y2"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float GetEuclideanDist(float x1, float y1, float x2, float y2)
    {
        float dx = x2 - x1;
        float dy = y2 - y1;
        float distance = Mathf.Sqrt(dx * dx + dy * dy);
        return distance;
    }

    /// <summary>
    /// 두 좌표를 2D 평면에서 최단 거리로 계산하여 반환합니다.
    /// </summary>
    /// <param name="pos1"></param>
    /// <param name="pos2"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float GetEuclideanDist(Vector2 pos1, Vector2 pos2)
    {
        float dx = pos2.x - pos1.x;
        float dy = pos2.y - pos1.y;
        float distance = Mathf.Sqrt(dx * dx + dy * dy);
        return distance;
    }

    /// <summary>
    /// 직선 이동과 대각선 이동에 동일한 점수를 부여합니다.
    /// 두 좌표를 2D 좌표계에서 최단 거리를 계산하여 반환합니다.
    /// </summary>
    /// <param name="x1"></param>
    /// <param name="y1"></param>
    /// <param name="x2"></param>
    /// <param name="y2"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float GetChebyshevDist(float x1, float y1, float x2, float y2)
    {
        float dx = Mathf.Abs(x2 - x1);
        float dy = Mathf.Abs(y2 - y1);
        return Mathf.Max(dx, dy);
    }

    /// <summary>
    /// 직선 이동과 대각선 이동에 동일한 점수를 부여합니다.
    /// 두 좌표를 2D 좌표계에서 최단 거리를 계산하여 반환합니다.
    /// </summary>
    /// <param name="pos1"></param>
    /// <param name="pos2"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float GetChebyshevDist(Vector2 pos1, Vector2 pos2)
    {
        float dx = Mathf.Abs(pos2.x - pos1.x);
        float dy = Mathf.Abs(pos2.y - pos1.y);
        return Mathf.Max(dx, dy);
    }

    /// <summary>
    /// 방향 벡터를 4가지 방향 중 하나로 변환하여 반환합니다.
    /// </summary>
    /// <param name="direction"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 GetDirection4(Vector2 direction)
    {
        if (direction.x == 0f && direction.y == 0f) {
            return Vector2.zero;
        }
        float absX = Mathf.Abs(direction.x);
        float absY = Mathf.Abs(direction.y);
        // 세로가 더 길다면 UP or Down
        if (absX < absY) {
            direction.x = 0;
            if (0 < direction.y) {
                direction.y = 1;
            } else {
                direction.y = -1;
            }
        }
        // 가로가 더 길다면 Left or Right
        else {
            direction.y = 0;
            if (0 < direction.x) {
                direction.x = 1;
            } else {
                direction.x = -1;
            }
        }
        return direction;
    }

    /// <summary>
    /// 방향 벡터를 4가지 방향 중 하나로 변환하여 반환합니다.
    /// </summary>
    /// <param name="direction"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2Int GetDirection4Int(Vector2 direction)
    {
        if (direction.x == 0f && direction.y == 0f) {
            return Vector2Int.zero;
        }
        float absX = Mathf.Abs(direction.x);
        float absY = Mathf.Abs(direction.y);
        // 세로가 더 길다면 UP or Down
        if (absX < absY) {
            if (0 < direction.y) {
                return new Vector2Int(0, 1);
            } else {
                return new Vector2Int(0, -1);
            }
        }
        // 가로가 더 길다면 Left or Right
        else {
            if (0 < direction.x) {
                return new Vector2Int(1, 0);
            } else {
                return new Vector2Int(-1, 0);
            }
        }
    }

    /// <summary>
    /// 방향 벡터를 8가지 방향 중 하나로 변환하여 반환합니다.
    /// </summary>
    /// <param name="direction"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2Int GetDirection8Int(Vector2 direction)
    {
        if (direction.x == 0f && direction.y == 0f) {
            return Vector2Int.zero;
        }
        // 방향 벡터를 각도로 변환
        float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        // -4 ~ 3 범위를 갖도록 나눈 후 복구
        int dir8 = Mathf.RoundToInt(angle / 45f);
        float angleTo8 = dir8 * 45f * Mathf.Deg2Rad;
        return new Vector2Int((int)Mathf.Cos(angleTo8), (int)Mathf.Sin(angleTo8));
    }

    /// <summary>
    /// 방향 벡터를 8가지 방향 중 하나로 변환하여 반환합니다.
    /// </summary>
    /// <param name="direction"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 GetDirection8(Vector2 direction)
    {
        if (direction.x == 0f && direction.y == 0f) {
            return Vector2Int.zero;
        }
        // 방향 벡터를 각도로 변환
        float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        // -4 ~ 3 범위를 갖도록 나눈 후 복구
        int dir8 = Mathf.RoundToInt(angle / 45f);
        float angleTo8 = dir8 * 45f * Mathf.Deg2Rad;
        direction.x = Mathf.Cos(angleTo8);
        direction.y = Mathf.Sin(angleTo8);
        return direction;
    }

    /// <summary>
    /// 두 벡터 사이의 거리의 제곱을 반환합니다.
    /// </summary>
    /// <param name="pos1"></param>
    /// <param name="pos2"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float GetDistanceSquare(Vector2 pos1, Vector2 pos2)
    {
        float dx = pos2.x - pos1.x;
        float dy = pos2.y - pos1.y;
        return dx * dx + dy * dy;
    }

    /// <summary>
    /// 두 좌표 사이의 거리의 제곱을 반환합니다.
    /// </summary>
    /// <param name="x1"></param>
    /// <param name="y1"></param>
    /// <param name="x2"></param>
    /// <param name="y2"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float GetDistanceSquare(float x1, float y1, float x2, float y2)
    {
        float dx = x2 - x1;
        float dy = y2 - y1;
        return dx * dx + dy * dy;
    }

    /// <summary>
    /// 두 점이 거리 이내에 있는지 검사합니다.
    /// </summary>
    /// <param name="pos1"></param>
    /// <param name="pos2"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsWithinDistance(Vector2 pos1, Vector2 pos2, float distance)
    {
        if (GetDistanceSquare(pos1, pos2) <= distance * distance) {
            return true;
        }
        return false;
    }

    /// <summary>
    /// 원점을 기준으로 벡터를 회전시킵니다.
    /// </summary>
    /// <param name="vector"></param>
    /// <param name="radian"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 Rotate(Vector2 vector, float radian)
    {
        float cos = Mathf.Cos(radian);
        float sin = Mathf.Sin(radian);
        // 2차원 회전 행렬
        float rotateX = vector.x * cos - vector.y * sin;
        float rotateY = vector.x * sin + vector.y * cos;
        vector.x = rotateX;
        vector.y = rotateY;
        return vector;
    }

    /// <summary>
    /// 점이 중심점을 기준으로 회전한 좌표를 반환합니다.
    /// </summary>
    /// <param name="center"></param>
    /// <param name="pos"></param>
    /// <param name="radian"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 RotatePoint(Vector2 center, Vector2 pos, float radian)
    {
        // center가 0일때 pos의 값
        float originX = pos.x - center.x;
        float originY = pos.y - center.y;
        // 회전했을 경우의 좌표
        float cos = Mathf.Cos(radian);
        float sin = Mathf.Sin(radian);
        float rotateX = originX * cos - originY * sin;
        float rotateY = originX * sin + originY * cos;
        // 결과
        pos.x = rotateX + center.x;
        pos.y = rotateY + center.y;
        return pos;
    }

    /// <summary>
    /// 클램프한 벡터를 반환합니다.
    /// </summary>
    /// <returns></returns>
    public static Vector2 ClampVector(Vector2 v, Vector2 min, Vector2 max)
    {
        if (v.x < min.x) v.x = min.x;
        if (v.y < min.y) v.y = min.y;
        if (max.x < v.x) v.x = max.x;
        if (max.y < v.y) v.y = max.y;
        return v;
    }

    /// <summary>
    /// 각도를 0° 이상 360° 미만 범위로 정규화합니다.
    /// </summary>
    /// <param name="degree"></param>
    /// <returns></returns>
    public static float NormalizeAngle(float degree)
    {
        while (360 <= degree) degree -= 360;
        while (degree < 0) degree += 360;
        return degree;
    }

    /// <summary>
    /// percent 확률로 true를 반환합니다.
    /// </summary>
    /// <param name="percent"></param>
    /// <returns></returns>
    public static bool IsProbability(float percent)
    {
        float rand = Random.Range(0f, 100f);
        if (rand < percent) {
            return true;
        }
        return false;
    }
}
 
// ======================================================== 
// 경로: C:\Users\MyPC\Documents\GitMing\Assets\Scripts\Utility\URange.cs 
// ======================================================== 
 
using System.Runtime.CompilerServices;
using UnityEngine;
/// <summary>
/// 범위 및 거리를 계산하는 유틸리티입니다.
/// </summary>
public class URange
{
    /// <summary>
    /// 두 좌표 사이의 거리가 일정 거리 이하인지 검사합니다.
    /// </summary>
    /// <param name="pos1"></param>
    /// <param name="pos2"></param>
    /// <param name="distance"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InCircle(Vector2 pos1, Vector2 pos2, float distance)
    {
        float sqrtDistance = distance * distance;
        float sqrtBetween = UMath.GetDistanceSquare(pos1, pos2);
        if (sqrtBetween < sqrtDistance) {
            return true;
        }
        return false;
    }

    /// <summary>
    /// 두 좌표 사이의 거리가 일정 거리 이하인지 검사합니다.
    /// </summary>
    /// <param name="x1"></param>
    /// <param name="y1"></param>
    /// <param name="x2"></param>
    /// <param name="y2"></param>
    /// <param name="distance"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InCircle(float x1, float y1, float x2, float y2, float distance)
    {
        float sqrtDistance = distance * distance;
        float sqrtBetween = UMath.GetDistanceSquare(x1, y1, x2, y2);
        if (sqrtBetween < sqrtDistance) {
            return true;
        }
        return false;
    }

    /// <summary>
    /// 좌표가 특정 좌표를 중심으로 한 사각형 범위 안에 있는지 검사합니다.
    /// </summary>
    /// <param name="pos"></param>
    /// <param name="rectPos"></param>
    /// <param name="diameter"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InRect(Vector2 pos, Vector2 rectPos, float diameter)
    {
        float left = rectPos.x - diameter;
        float right = rectPos.x + diameter;
        float up = rectPos.y - diameter;
        float down = rectPos.y + diameter;
        if (pos.x < left) return false;
        if (right < pos.x) return false;
        if (pos.y < down) return false;
        if (up < pos.y) return false;
        return true;
    }

    /// <summary>
    /// 좌표가 특정 좌표를 중심으로 한 사각형 범위 안에 있는지 검사합니다.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="rectX"></param>
    /// <param name="rectY"></param>
    /// <param name="diameter"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool InRect(float x, float y, float rectX, float rectY, float diameter)
    {
        float left = rectX - diameter;
        float right = rectX + diameter;
        float up = rectY - diameter;
        float down = rectY + diameter;
        if (x < left) return false;
        if (right < x) return false;
        if (y < down) return false;
        if (up < y) return false;
        return true;
    }
}
